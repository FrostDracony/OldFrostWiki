{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to FrostWiki! Thanks for visiting the site! I am the creator of it, FrostDracony, and you can find here some tutorials of Slime Rancher modding. Click above on Slime Rancher to read the tutorials that are there. Links Slime Rancher modding tutorials - Click here to access the Slime Rancher modding tutorials","title":"Home"},{"location":"#welcome-to-frostwiki","text":"Thanks for visiting the site! I am the creator of it, FrostDracony, and you can find here some tutorials of Slime Rancher modding. Click above on Slime Rancher to read the tutorials that are there.","title":"Welcome to FrostWiki!"},{"location":"#links","text":"Slime Rancher modding tutorials - Click here to access the Slime Rancher modding tutorials","title":"Links"},{"location":"Slime_Rancher/choice_modlauncher/","text":"Basic Requirements You will need Visual Studio (read further to know how to install it) To know some basics of C# (I will not explain what's e.g. a function/variable/etc mean, you litteraly can search on Internet how to code in C#) The requirements apply to all the 3 mod launchers Note from RicTheCoder C# is the Coding Language you use to mod, the same the game was written on. Unity is the Game Engine, software used to create the game. C# is required cause you can't write code for the game otherwise Unity is optional, but you will need it in order to make certain things like importing assets into the game like icons, models, etc. To write code in C# you need an IDE (a program to write and compile code) that allows you to write code in C#, the most used one, specially for modding SR is Visual Studio, and as a beginner you should stick to it. RicTheCoder Choice the tutorials about your modlauncher At the moment of writing this, Slime Rancher has 3 modlaunchers: SRML (Slime Rancher Mod Loader) UMF (uMod Framework) Guu (Coming soon) They all have different ways to achieve the same goal: create mods for the game. You may choice the one that you want (Note that UMF has his own wiki, you should check it out).","title":"Basic Requirements"},{"location":"Slime_Rancher/choice_modlauncher/#basic-requirements","text":"You will need Visual Studio (read further to know how to install it) To know some basics of C# (I will not explain what's e.g. a function/variable/etc mean, you litteraly can search on Internet how to code in C#) The requirements apply to all the 3 mod launchers Note from RicTheCoder C# is the Coding Language you use to mod, the same the game was written on. Unity is the Game Engine, software used to create the game. C# is required cause you can't write code for the game otherwise Unity is optional, but you will need it in order to make certain things like importing assets into the game like icons, models, etc. To write code in C# you need an IDE (a program to write and compile code) that allows you to write code in C#, the most used one, specially for modding SR is Visual Studio, and as a beginner you should stick to it. RicTheCoder","title":"Basic Requirements"},{"location":"Slime_Rancher/choice_modlauncher/#choice-the-tutorials-about-your-modlauncher","text":"At the moment of writing this, Slime Rancher has 3 modlaunchers: SRML (Slime Rancher Mod Loader) UMF (uMod Framework) Guu (Coming soon) They all have different ways to achieve the same goal: create mods for the game. You may choice the one that you want (Note that UMF has his own wiki, you should check it out).","title":"Choice the tutorials about your modlauncher"},{"location":"Slime_Rancher/SRML/SRML/","text":"Tutorials for SRML Here you will find some tutorials about modding Slime Rancher using SRML: Chapter 1 - The basics 1: Getting started 2: Modifying crates 3: Creating Enums Chapter 2 - Let's make cute slimes! 1: Creating custom slimes Chapter 3 - Tasty food incoming! 1: Creating custom food 2: Make custom food grow Chapter 4 - Gadgets, items and ...more? 1: Creating custom item","title":"SRML"},{"location":"Slime_Rancher/SRML/SRML/#tutorials-for-srml","text":"Here you will find some tutorials about modding Slime Rancher using SRML:","title":"Tutorials for SRML"},{"location":"Slime_Rancher/SRML/SRML/#chapter-1-the-basics","text":"1: Getting started 2: Modifying crates 3: Creating Enums","title":"Chapter 1 - The basics"},{"location":"Slime_Rancher/SRML/SRML/#chapter-2-lets-make-cute-slimes","text":"1: Creating custom slimes","title":"Chapter 2 - Let's make cute slimes!"},{"location":"Slime_Rancher/SRML/SRML/#chapter-3-tasty-food-incoming","text":"1: Creating custom food 2: Make custom food grow","title":"Chapter 3 - Tasty food incoming!"},{"location":"Slime_Rancher/SRML/SRML/#chapter-4-gadgets-items-and-more","text":"1: Creating custom item","title":"Chapter 4 - Gadgets, items and ...more?"},{"location":"Slime_Rancher/SRML/creating_enums/","text":"Planning If you saw/completed the last tutorial, then you are maybe wondering on how to create our own objects instead of modifying the existing objects inside the game (like crates). And this is what you are looking for! Theory When I am talking about Enums, I usually mean Ids. Now, what is an Id? (Keep in mind that I am not the creator of SRML, so you should look the \"official\" definition too). In the most games, an Id represent an object. This means that for (almost) all objects in Slime Rancher an Id exists (you already used one in the last tutorial, the Id.CRATE_PARTY_01 ). Creating an Enum/Id While you are modding, you will not only use Id, but there are cases where you will need uses other, custom Enums. Luckly SRML provides us an Attribute (you don't need to know what they do for this tutorial) that create for us custom Enums, the EnumHolder . Location You can't continue to write everything in your Main script, it will end in a mess (but if you are doing a small mod then you may, remember that you can do everything you want as long it works). What I make is that I create a new file (choice the Location that you want) where I will store all my Ids. I will call it \"ModdedIds\" (again, you may change the name to what you want). Starting creating Enums Now, you finally can start creating your Enum. At first you will need to import the EnumHolder , else it won't work. You achieve adding a using SRML.Utils.Enum; . Then, create a class called Ids (you can change it). Adding an Enum For this tutorial I will add an test Enum for a crate. Now you may copy-paste this code snippet (I explained all lines on the side): using System ; using SRML.Utils.Enum ; namespace ModdedIds { [EnumHolder] //With this, you are indicating SRML that all the `public static readonly` variables are Enums class Ids { public static readonly Identifiable . Id CUSTOM_CRATE ; //You created your first Enum! } } Warning All enum has to be written in CAPS, else there will be an error So public static readonly Identifiable.Id Custom_Create will result in an error! Side Notes Don't use the new Enum, for now it's only an Enum with no value, you may use it in more advanced tutorials. You may find the original tutorial usefull, too Return to the main place","title":"Planning"},{"location":"Slime_Rancher/SRML/creating_enums/#planning","text":"If you saw/completed the last tutorial, then you are maybe wondering on how to create our own objects instead of modifying the existing objects inside the game (like crates). And this is what you are looking for!","title":"Planning"},{"location":"Slime_Rancher/SRML/creating_enums/#theory","text":"When I am talking about Enums, I usually mean Ids. Now, what is an Id? (Keep in mind that I am not the creator of SRML, so you should look the \"official\" definition too). In the most games, an Id represent an object. This means that for (almost) all objects in Slime Rancher an Id exists (you already used one in the last tutorial, the Id.CRATE_PARTY_01 ).","title":"Theory"},{"location":"Slime_Rancher/SRML/creating_enums/#creating-an-enumid","text":"While you are modding, you will not only use Id, but there are cases where you will need uses other, custom Enums. Luckly SRML provides us an Attribute (you don't need to know what they do for this tutorial) that create for us custom Enums, the EnumHolder .","title":"Creating an Enum/Id"},{"location":"Slime_Rancher/SRML/creating_enums/#location","text":"You can't continue to write everything in your Main script, it will end in a mess (but if you are doing a small mod then you may, remember that you can do everything you want as long it works). What I make is that I create a new file (choice the Location that you want) where I will store all my Ids. I will call it \"ModdedIds\" (again, you may change the name to what you want).","title":"Location"},{"location":"Slime_Rancher/SRML/creating_enums/#starting-creating-enums","text":"Now, you finally can start creating your Enum. At first you will need to import the EnumHolder , else it won't work. You achieve adding a using SRML.Utils.Enum; . Then, create a class called Ids (you can change it).","title":"Starting creating Enums"},{"location":"Slime_Rancher/SRML/creating_enums/#adding-an-enum","text":"For this tutorial I will add an test Enum for a crate. Now you may copy-paste this code snippet (I explained all lines on the side): using System ; using SRML.Utils.Enum ; namespace ModdedIds { [EnumHolder] //With this, you are indicating SRML that all the `public static readonly` variables are Enums class Ids { public static readonly Identifiable . Id CUSTOM_CRATE ; //You created your first Enum! } } Warning All enum has to be written in CAPS, else there will be an error So public static readonly Identifiable.Id Custom_Create will result in an error!","title":"Adding an Enum"},{"location":"Slime_Rancher/SRML/creating_enums/#side-notes","text":"Don't use the new Enum, for now it's only an Enum with no value, you may use it in more advanced tutorials. You may find the original tutorial usefull, too","title":"Side Notes"},{"location":"Slime_Rancher/SRML/creating_enums/#return-to-the-main-place","text":"","title":"Return to the main place"},{"location":"Slime_Rancher/SRML/creating_new_bar/","text":"You need to import the references UnityEngine.UI Unity.TextMeshPro","title":"Creating new bar"},{"location":"Slime_Rancher/SRML/getting_started/","text":"Getting Started Install SRML You can find all informations on the creator's github on how to install SRML This section is \"quick\", but because the whole tutorial is located in the veesusmikelheir's github, the creator of SRML . The next will be longer. veesusmikelheir's starting tutorials are in this order: Getting Started Project Setup Understand the basics Our Class1.cs file (you can change the name to main, but everytime that I will say \"main\" file I am refering to the \"Class1\" file) is the entry point for your mod. This is where the mod's code starts. You have 3 functions: PreLoad Load PostLoad Now I am just going to copy-paste what the creator of SRML wrote about these 3 functions : PreLoad This step is the primary registration step and is used for registering completely custom assets and objects. It is also the only step where you're able to add new values to enums. GameContext.Instance has not yet been set during this step, as it happens before GameContext.Awake, so be careful what you use. Load This step is a secondary loading step where you have access to GameContext.Instance, and can interact with vanilla game assets. PostLoad PostLoad is a tertiary loading step where all modded data is registered, and thus can be manipulated. Use this step for manipulating existing objects or assets. Patching When talking about \"Game Patching\", it is the same as \"modifying the game\". Slime Rancher is a already, programmed, game, but our goal is to mod it. The ModLoaders usually do it already for us (More in advanced tutorial). They add new things (custom food, slimes and etc...) that we created, modify existing objects (see next tutorial as reference) or even remove objects of the game self (advanced). Conclusion Now in other words: Preload is for register new things and enum values and to do all the harmony patching (you don't have to know what's patching for now) Load is used for registering things that require a loaded gamecontext (So once the game is loaded, you then can use the gamecontext singleton. In the next tutorial we will use it) PostLoad is used for editing existing assets in the game, not a registry step (for example change some images/models/etc.) And Patching is the same as changing things of the game. Return to the main place","title":"Getting Started"},{"location":"Slime_Rancher/SRML/getting_started/#getting-started","text":"","title":"Getting Started"},{"location":"Slime_Rancher/SRML/getting_started/#install-srml","text":"You can find all informations on the creator's github on how to install SRML This section is \"quick\", but because the whole tutorial is located in the veesusmikelheir's github, the creator of SRML . The next will be longer. veesusmikelheir's starting tutorials are in this order: Getting Started Project Setup","title":"Install SRML"},{"location":"Slime_Rancher/SRML/getting_started/#understand-the-basics","text":"Our Class1.cs file (you can change the name to main, but everytime that I will say \"main\" file I am refering to the \"Class1\" file) is the entry point for your mod. This is where the mod's code starts. You have 3 functions: PreLoad Load PostLoad Now I am just going to copy-paste what the creator of SRML wrote about these 3 functions :","title":"Understand the basics"},{"location":"Slime_Rancher/SRML/getting_started/#preload","text":"This step is the primary registration step and is used for registering completely custom assets and objects. It is also the only step where you're able to add new values to enums. GameContext.Instance has not yet been set during this step, as it happens before GameContext.Awake, so be careful what you use.","title":"PreLoad"},{"location":"Slime_Rancher/SRML/getting_started/#load","text":"This step is a secondary loading step where you have access to GameContext.Instance, and can interact with vanilla game assets.","title":"Load"},{"location":"Slime_Rancher/SRML/getting_started/#postload","text":"PostLoad is a tertiary loading step where all modded data is registered, and thus can be manipulated. Use this step for manipulating existing objects or assets.","title":"PostLoad"},{"location":"Slime_Rancher/SRML/getting_started/#patching","text":"When talking about \"Game Patching\", it is the same as \"modifying the game\". Slime Rancher is a already, programmed, game, but our goal is to mod it. The ModLoaders usually do it already for us (More in advanced tutorial). They add new things (custom food, slimes and etc...) that we created, modify existing objects (see next tutorial as reference) or even remove objects of the game self (advanced).","title":"Patching"},{"location":"Slime_Rancher/SRML/getting_started/#conclusion","text":"Now in other words: Preload is for register new things and enum values and to do all the harmony patching (you don't have to know what's patching for now) Load is used for registering things that require a loaded gamecontext (So once the game is loaded, you then can use the gamecontext singleton. In the next tutorial we will use it) PostLoad is used for editing existing assets in the game, not a registry step (for example change some images/models/etc.) And Patching is the same as changing things of the game.","title":"Conclusion"},{"location":"Slime_Rancher/SRML/getting_started/#return-to-the-main-place","text":"","title":"Return to the main place"},{"location":"Slime_Rancher/SRML/modifying_crates/","text":"Planning Slime Rancher is a really complicated game to mod, so we will start with something that's simple: We all know that we can't collect crates, they stick on the vacuum gun and you can shoot them... but what if we can vacuum them? And that's what we are going to do! Definition Here are the explanations of some words: Identifiable.Id The creator explained it on the github of SRML. Ammo Ammo is the same as Inventory. Vaccumable/to vacuum Collectable/to collect LookupDirector The creator explained it on the github of SRML. PediaDirector The creator explained it on the github of SRML. How to start We will insert the next code snippet in the Load or PostLoad function in our main class, you can choice where to put. AmmoRegistry . RegisterAmmoPrefab ( PlayerState . AmmoMode . DEFAULT , SRSingleton < GameContext >. Instance . LookupDirector . GetPrefab ( Identifiable . Id . CRATE_PARTY_01 )); Sprite icon = SRSingleton < SceneContext >. Instance . PediaDirector . entries . First (( PediaDirector . IdEntry x ) => x . id == PediaDirector . Id . ORNAMENTS ). icon ; LookupRegistry . RegisterVacEntry ( Identifiable . Id . CRATE_PARTY_01 , new Color32 ( 138 , 87 , 40 , 255 ), icon ); SRSingleton < GameContext >. Instance . LookupDirector . GetPrefab ( Identifiable . Id . CRATE_PARTY_01 ). GetComponent < Vacuumable >(). size = Vacuumable . Size . NORMAL ; First Line Now, I will explain every line and what it does: AmmoRegistry . RegisterAmmoPrefab ( PlayerState . AmmoMode . DEFAULT , SRSingleton < GameContext >. Instance . LookupDirector . GetPrefab ( Identifiable . Id . CRATE_PARTY_01 )); Now, lets start with the method AmmoRegistry . RegisterAmmoPrefab We are making the crate vaccumable. This method accept 2 parameters: An AmmoMode Enum The target GameObject There only exist 2 AmmoMode: DEFAULT (Normal) NIMBLE_VALLEY (Once you pass the gate of Mochi, the item will disappear) For this tutorial we want the DEFAULT (Normal) Enum. Then, we need a GameObject, it's mean just a object of the game. We want to get the crate party for this example. SRSingleton < GameContext >. Instance . LookupDirector We are getting the GameContext( SRSingleton<GameContext>.Instance ) to then get the LookupDirector. The LookupDirector contains a GetPrefab method, wich requires a Identifiable.Id and returns the GameObject of it. TL;DR (the second parameter) We are getting the GameObject of our Crate. Second Line Sprite icon = SRSingleton < SceneContext >. Instance . PediaDirector . entries . First (( PediaDirector . IdEntry x ) => x . id == PediaDirector . Id . ORNAMENTS ). icon ; All collectable objects of the game have their own picture, so why not our? And that's what we are doing! Sprite icon = SRSingleton < SceneContext >. Instance . PediaDirector Like with the LookupDirector, we are getting the PediaDirector from the SceneContext. PediaDirector . entries All the icons/images of the game entries . First (( PediaDirector . IdEntry x ) => x . id == PediaDirector . Id . ORNAMENTS ). icon We are targeting the Ornaments (These christmas balls), getting some sort of object and getting the icon of it. You can change the PediaDirector.Id to the object that you want to have the image Third Line LookupRegistry . RegisterVacEntry ( Identifiable . Id . CRATE_PARTY_01 , new Color32 ( 138 , 87 , 40 , 255 ), icon ); Here we are assigning some background color and our icon to our crate. LookupRegistry . RegisterVacEntry This method requires 3 parameters: The Identifiable.Id of the object that we want to give the colour and icon The Colour that we want to give The Icon that we want to give We already have the Id and the Icon, but for the colour you will have to use a rgb sequence. You can go to this website ; play around with the settings until you found your colour. Then just copy the number at the red (default 47), then green (default 50) and blue (default 159) slide and put them into the parameters of the new Color32() . So it would be new Color32(47, 50, 159, 255) (first red, then green and finally blue: This order has to be correct!). The last parameter, the 255, is needed for the transparency: You don't will need it. Fourth Line SRSingleton < GameContext >. Instance . LookupDirector . GetPrefab ( Identifiable . Id . CRATE_PARTY_01 ). GetComponent < Vacuumable >(). size = Vacuumable . Size . NORMAL ; Here we are making the crate actually vaccumable. Remember, in the first line we only made it \"storagable\", so that it can enter the inventory, but if you would run your mod then the crate still will stick on the gun and not enter. SRSingleton < GameContext >. Instance . LookupDirector . GetPrefab ( Identifiable . Id . CRATE_PARTY_01 ) We already saw this on the first line, we are getting the GameObject of our crate. . GetComponent < Vacuumable >(). size = Vacuumable . Size . NORMAL ; Now we are getting the \"Vacuumable Component\" (Think this like a folder), then changing the size property to Vacuumable.Size.NORMAL . We have 3 type of sizes: NORMAL LARGE GIANT Normal is the.. normal size. This means it can be collected. Large means that it will stick on the vacuum gun (like a normal crate) Giant means that it can't be collected at all, like a gordo. Fifth/Last Line TranslationPatcher . AddActorTranslation ( \"l.crate_party_01\" , \"Party Crate\" ); You can leave it, but this will add the little \"Party Crate\" name in your inventory when you are storing a party crate. We are doing this because crates aren't vacuumable, so there dosen't exist any name that should show up when you have one crate in your inventory. So we have to add one ourself! Conclusion This is a long tutorial, but only because I tried to explain everything in details. This is really confusing at start, but you will get the point. Anyways, the next tutorial part is to add custom slimes (warning, it's a really long part), so enjoy your new crate! P.S. But FrostDracony, where can I find a party crate? I don't want to search the entire map for one! Ok, keep calm: Just spawn one! On Windwos, you can press Ctrl + Tab to access the command bar. Type in spawn CRATE_PARTY_01 and a party crate should spawn where you were looking at! (If it doesn't spawn, then it probably spawned below the map.. Just find a flat place like the ranch and retry the command) Return to the main place","title":"Planning"},{"location":"Slime_Rancher/SRML/modifying_crates/#planning","text":"Slime Rancher is a really complicated game to mod, so we will start with something that's simple: We all know that we can't collect crates, they stick on the vacuum gun and you can shoot them... but what if we can vacuum them? And that's what we are going to do!","title":"Planning"},{"location":"Slime_Rancher/SRML/modifying_crates/#definition","text":"Here are the explanations of some words:","title":"Definition"},{"location":"Slime_Rancher/SRML/modifying_crates/#identifiableid","text":"The creator explained it on the github of SRML.","title":"Identifiable.Id"},{"location":"Slime_Rancher/SRML/modifying_crates/#ammo","text":"Ammo is the same as Inventory.","title":"Ammo"},{"location":"Slime_Rancher/SRML/modifying_crates/#vaccumableto-vacuum","text":"Collectable/to collect","title":"Vaccumable/to vacuum"},{"location":"Slime_Rancher/SRML/modifying_crates/#lookupdirector","text":"The creator explained it on the github of SRML.","title":"LookupDirector"},{"location":"Slime_Rancher/SRML/modifying_crates/#pediadirector","text":"The creator explained it on the github of SRML.","title":"PediaDirector"},{"location":"Slime_Rancher/SRML/modifying_crates/#how-to-start","text":"We will insert the next code snippet in the Load or PostLoad function in our main class, you can choice where to put. AmmoRegistry . RegisterAmmoPrefab ( PlayerState . AmmoMode . DEFAULT , SRSingleton < GameContext >. Instance . LookupDirector . GetPrefab ( Identifiable . Id . CRATE_PARTY_01 )); Sprite icon = SRSingleton < SceneContext >. Instance . PediaDirector . entries . First (( PediaDirector . IdEntry x ) => x . id == PediaDirector . Id . ORNAMENTS ). icon ; LookupRegistry . RegisterVacEntry ( Identifiable . Id . CRATE_PARTY_01 , new Color32 ( 138 , 87 , 40 , 255 ), icon ); SRSingleton < GameContext >. Instance . LookupDirector . GetPrefab ( Identifiable . Id . CRATE_PARTY_01 ). GetComponent < Vacuumable >(). size = Vacuumable . Size . NORMAL ;","title":"How to start"},{"location":"Slime_Rancher/SRML/modifying_crates/#first-line","text":"Now, I will explain every line and what it does: AmmoRegistry . RegisterAmmoPrefab ( PlayerState . AmmoMode . DEFAULT , SRSingleton < GameContext >. Instance . LookupDirector . GetPrefab ( Identifiable . Id . CRATE_PARTY_01 )); Now, lets start with the method AmmoRegistry . RegisterAmmoPrefab We are making the crate vaccumable. This method accept 2 parameters: An AmmoMode Enum The target GameObject There only exist 2 AmmoMode: DEFAULT (Normal) NIMBLE_VALLEY (Once you pass the gate of Mochi, the item will disappear) For this tutorial we want the DEFAULT (Normal) Enum. Then, we need a GameObject, it's mean just a object of the game. We want to get the crate party for this example. SRSingleton < GameContext >. Instance . LookupDirector We are getting the GameContext( SRSingleton<GameContext>.Instance ) to then get the LookupDirector. The LookupDirector contains a GetPrefab method, wich requires a Identifiable.Id and returns the GameObject of it. TL;DR (the second parameter) We are getting the GameObject of our Crate.","title":"First Line"},{"location":"Slime_Rancher/SRML/modifying_crates/#second-line","text":"Sprite icon = SRSingleton < SceneContext >. Instance . PediaDirector . entries . First (( PediaDirector . IdEntry x ) => x . id == PediaDirector . Id . ORNAMENTS ). icon ; All collectable objects of the game have their own picture, so why not our? And that's what we are doing! Sprite icon = SRSingleton < SceneContext >. Instance . PediaDirector Like with the LookupDirector, we are getting the PediaDirector from the SceneContext. PediaDirector . entries All the icons/images of the game entries . First (( PediaDirector . IdEntry x ) => x . id == PediaDirector . Id . ORNAMENTS ). icon We are targeting the Ornaments (These christmas balls), getting some sort of object and getting the icon of it. You can change the PediaDirector.Id to the object that you want to have the image","title":"Second Line"},{"location":"Slime_Rancher/SRML/modifying_crates/#third-line","text":"LookupRegistry . RegisterVacEntry ( Identifiable . Id . CRATE_PARTY_01 , new Color32 ( 138 , 87 , 40 , 255 ), icon ); Here we are assigning some background color and our icon to our crate. LookupRegistry . RegisterVacEntry This method requires 3 parameters: The Identifiable.Id of the object that we want to give the colour and icon The Colour that we want to give The Icon that we want to give We already have the Id and the Icon, but for the colour you will have to use a rgb sequence. You can go to this website ; play around with the settings until you found your colour. Then just copy the number at the red (default 47), then green (default 50) and blue (default 159) slide and put them into the parameters of the new Color32() . So it would be new Color32(47, 50, 159, 255) (first red, then green and finally blue: This order has to be correct!). The last parameter, the 255, is needed for the transparency: You don't will need it.","title":"Third Line"},{"location":"Slime_Rancher/SRML/modifying_crates/#fourth-line","text":"SRSingleton < GameContext >. Instance . LookupDirector . GetPrefab ( Identifiable . Id . CRATE_PARTY_01 ). GetComponent < Vacuumable >(). size = Vacuumable . Size . NORMAL ; Here we are making the crate actually vaccumable. Remember, in the first line we only made it \"storagable\", so that it can enter the inventory, but if you would run your mod then the crate still will stick on the gun and not enter. SRSingleton < GameContext >. Instance . LookupDirector . GetPrefab ( Identifiable . Id . CRATE_PARTY_01 ) We already saw this on the first line, we are getting the GameObject of our crate. . GetComponent < Vacuumable >(). size = Vacuumable . Size . NORMAL ; Now we are getting the \"Vacuumable Component\" (Think this like a folder), then changing the size property to Vacuumable.Size.NORMAL . We have 3 type of sizes: NORMAL LARGE GIANT Normal is the.. normal size. This means it can be collected. Large means that it will stick on the vacuum gun (like a normal crate) Giant means that it can't be collected at all, like a gordo.","title":"Fourth Line"},{"location":"Slime_Rancher/SRML/modifying_crates/#fifthlast-line","text":"TranslationPatcher . AddActorTranslation ( \"l.crate_party_01\" , \"Party Crate\" ); You can leave it, but this will add the little \"Party Crate\" name in your inventory when you are storing a party crate. We are doing this because crates aren't vacuumable, so there dosen't exist any name that should show up when you have one crate in your inventory. So we have to add one ourself!","title":"Fifth/Last Line"},{"location":"Slime_Rancher/SRML/modifying_crates/#conclusion","text":"This is a long tutorial, but only because I tried to explain everything in details. This is really confusing at start, but you will get the point. Anyways, the next tutorial part is to add custom slimes (warning, it's a really long part), so enjoy your new crate!","title":"Conclusion"},{"location":"Slime_Rancher/SRML/modifying_crates/#ps","text":"But FrostDracony, where can I find a party crate? I don't want to search the entire map for one! Ok, keep calm: Just spawn one! On Windwos, you can press Ctrl + Tab to access the command bar. Type in spawn CRATE_PARTY_01 and a party crate should spawn where you were looking at! (If it doesn't spawn, then it probably spawned below the map.. Just find a flat place like the ranch and retry the command)","title":"P.S."},{"location":"Slime_Rancher/SRML/modifying_crates/#return-to-the-main-place","text":"","title":"Return to the main place"},{"location":"Slime_Rancher/SRML/CustomFood/advanced_mesh/","text":"Warning This isn't still stable, I am working on finding a better way, this is everything that I have at the moment: Just don't use it, it's to give you an idea on how it should work Requirements The getting started tutorial about slime rancher foods Creating custom Enums Setup Remember, you want to have the full controll about, so you need a extra setup. Thanks to MegaPiggy for this image (and his huge help he gave me): Credit: MegaPiggy Loading it into the game Create a new class, call it something (e.g. FoodCreator), and create a new function (call it what you want). Now, write into this function (you need to write using UnityEngine , else it won't work): GameObject YourObject = YourMainClass . assetBundle . LoadAsset < GameObject >( \"NAME OF OBJECT HERE\" ); //Your mesh located into the assetbundle GameObject FoodPrefab = PrefabUtils . CopyPrefab ( SRSingleton < GameContext >. Instance . LookupDirector . GetPrefab ( Identifiable . Id . OCAOCA_VEGGIE )); //It can be everything, as long this is a fruit/vegetable DragFloatReactor DFRComponent = YourObject . AddComponent < DragFloatReactor >(). GetCopyOf ( FoodPrefab . GetComponent < DragFloatReactor >()); ResourceCycle RCComponent = YourObject . AddComponent < ResourceCycle >(). GetCopyOf ( FoodPrefab . GetComponent < ResourceCycle >()); SECTR_PointSource SECTRComponent = YourObject . AddComponent < SECTR_PointSource >(). GetCopyOf ( FoodPrefab . GetComponent < SECTR_PointSource >()); CollisionAggregator CAComponent = YourObject . AddComponent < CollisionAggregator >(). GetCopyOf ( FoodPrefab . GetComponent < CollisionAggregator >()); RegionMember RMComponent = YourObject . AddComponent < RegionMember >(). GetCopyOf ( FoodPrefab . GetComponent < RegionMember >()); PlaySoundOnHit PSOHComponent = YourObject . AddComponent < PlaySoundOnHit >(). GetCopyOf ( FoodPrefab . GetComponent < PlaySoundOnHit >()); Identifiable IdentifiableComponent = YourObject . AddComponent < Identifiable >(). GetCopyOf ( FoodPrefab . GetComponent < Identifiable >()); Vacuumable VacuumableComponent = YourObject . AddComponent < Vacuumable >(). GetCopyOf ( FoodPrefab . GetComponent < Vacuumable >()); IdentifiableComponent . id = YourCustomEnum ; VacuumableComponent . size = Vacuumable . Size . NORMAL ; GameObject DelaunchTrigger = YourObject . transform . Find ( \"DelaunchTrigger\" ). gameObject ; DelaunchTrigger . AddComponent < VacDelaunchTrigger >(); return YourObject Now, in Load or PostLoad , add these lines: LookupRegistry . RegisterIdentifiablePrefab ( YourObject ); Identifiable . FOOD_CLASS . Add ( YourCustomEnum ); Identifiable . NON_SLIMES_CLASS . Add ( YourCustomEnum ); And you have it! You can go into the game and spawn your food writing spawn yourfoodenum in the command bar (Crtl + tab).","title":"Advanced mesh"},{"location":"Slime_Rancher/SRML/CustomFood/advanced_mesh/#requirements","text":"The getting started tutorial about slime rancher foods Creating custom Enums","title":"Requirements"},{"location":"Slime_Rancher/SRML/CustomFood/advanced_mesh/#setup","text":"Remember, you want to have the full controll about, so you need a extra setup. Thanks to MegaPiggy for this image (and his huge help he gave me): Credit: MegaPiggy","title":"Setup"},{"location":"Slime_Rancher/SRML/CustomFood/advanced_mesh/#loading-it-into-the-game","text":"Create a new class, call it something (e.g. FoodCreator), and create a new function (call it what you want). Now, write into this function (you need to write using UnityEngine , else it won't work): GameObject YourObject = YourMainClass . assetBundle . LoadAsset < GameObject >( \"NAME OF OBJECT HERE\" ); //Your mesh located into the assetbundle GameObject FoodPrefab = PrefabUtils . CopyPrefab ( SRSingleton < GameContext >. Instance . LookupDirector . GetPrefab ( Identifiable . Id . OCAOCA_VEGGIE )); //It can be everything, as long this is a fruit/vegetable DragFloatReactor DFRComponent = YourObject . AddComponent < DragFloatReactor >(). GetCopyOf ( FoodPrefab . GetComponent < DragFloatReactor >()); ResourceCycle RCComponent = YourObject . AddComponent < ResourceCycle >(). GetCopyOf ( FoodPrefab . GetComponent < ResourceCycle >()); SECTR_PointSource SECTRComponent = YourObject . AddComponent < SECTR_PointSource >(). GetCopyOf ( FoodPrefab . GetComponent < SECTR_PointSource >()); CollisionAggregator CAComponent = YourObject . AddComponent < CollisionAggregator >(). GetCopyOf ( FoodPrefab . GetComponent < CollisionAggregator >()); RegionMember RMComponent = YourObject . AddComponent < RegionMember >(). GetCopyOf ( FoodPrefab . GetComponent < RegionMember >()); PlaySoundOnHit PSOHComponent = YourObject . AddComponent < PlaySoundOnHit >(). GetCopyOf ( FoodPrefab . GetComponent < PlaySoundOnHit >()); Identifiable IdentifiableComponent = YourObject . AddComponent < Identifiable >(). GetCopyOf ( FoodPrefab . GetComponent < Identifiable >()); Vacuumable VacuumableComponent = YourObject . AddComponent < Vacuumable >(). GetCopyOf ( FoodPrefab . GetComponent < Vacuumable >()); IdentifiableComponent . id = YourCustomEnum ; VacuumableComponent . size = Vacuumable . Size . NORMAL ; GameObject DelaunchTrigger = YourObject . transform . Find ( \"DelaunchTrigger\" ). gameObject ; DelaunchTrigger . AddComponent < VacDelaunchTrigger >(); return YourObject Now, in Load or PostLoad , add these lines: LookupRegistry . RegisterIdentifiablePrefab ( YourObject ); Identifiable . FOOD_CLASS . Add ( YourCustomEnum ); Identifiable . NON_SLIMES_CLASS . Add ( YourCustomEnum ); And you have it! You can go into the game and spawn your food writing spawn yourfoodenum in the command bar (Crtl + tab).","title":"Loading it into the game"},{"location":"Slime_Rancher/SRML/CustomFood/getting_started/","text":"Note Thanks a lot to MegaPiggy for his huge help Requirements Unity 2019.4.11 (this specific version) To know how to create assetbundles To know how Unity's scripts works Add the reference UnityEngine.AssetBundleModule (look this on how to import references) The AssetBundle If you created something like a Mesh, an Image and else, you will have to create an assetbundle in order to import the thing into the game. There are many tutorials out there, feel free to use another tutorial for exporting assetbundles if you want (Don't change your Unity version, it has to be the 2019.4.11). I really recommand this video wich helped me a lot (only watch until 7:11 ) For anyone who can't access youtube, this is my version The first step is to download this Unity version. Quote \"From Lionmeow \" After installing Unity, a little setup is next you'll need to create a folder named AssetBundles and create a script named AssetBundleCreator: #if UNITY_EDITOR using UnityEngine ; using UnityEditor ; public class AssetBundleCreator : MonoBehaviour { [MenuItem(\"Assets/Build Asset Bundle\")] static void BuildBundles () { if ( BuildPipeline . BuildAssetBundles ( \"Assets/AssetBundles\" , BuildAssetBundleOptions . None , BuildTarget . StandaloneWindows )) { print ( \"Successfully exported AssetBundles!\" ); } else { print ( \"Something went wrong!\" ); } } } #endif You should be able to find your assetbundle at this location: C:YourUnityProjectFolder\\Assets\\AssetBundles Inserting the assetbundle into Visual Studio Then, insert your mesh/image into a folder (call it what you want, it dosen't matters), select a tag name at right-bottom and you now are able to export your mesh. Next, in your main class, add this line of code (remember to import adding it as reference, watch the requirements on how to do that) AssetBundle assetBundle = AssetBundle . LoadFromStream ( Assembly . GetExecutingAssembly (). GetManifestResourceStream ( typeof ( Main ), \"NAME OF BUNDLE\" )); And you loaded your assetbundle into visualstudio. At all time, if you want to grab something from it, write: assetBundle . LoadAsset < TargetType >( \"ASSET NAME\" ); Now you have 2 ways to create a food: The normal one (more performance/beginner friendly) The advanced one (have the full controll about your mesh, not really performance/beginner friendly) Good luck!","title":"Getting started"},{"location":"Slime_Rancher/SRML/CustomFood/getting_started/#requirements","text":"Unity 2019.4.11 (this specific version) To know how to create assetbundles To know how Unity's scripts works Add the reference UnityEngine.AssetBundleModule (look this on how to import references)","title":"Requirements"},{"location":"Slime_Rancher/SRML/CustomFood/getting_started/#the-assetbundle","text":"If you created something like a Mesh, an Image and else, you will have to create an assetbundle in order to import the thing into the game. There are many tutorials out there, feel free to use another tutorial for exporting assetbundles if you want (Don't change your Unity version, it has to be the 2019.4.11). I really recommand this video wich helped me a lot (only watch until 7:11 ) For anyone who can't access youtube, this is my version The first step is to download this Unity version. Quote \"From Lionmeow \" After installing Unity, a little setup is next you'll need to create a folder named AssetBundles and create a script named AssetBundleCreator: #if UNITY_EDITOR using UnityEngine ; using UnityEditor ; public class AssetBundleCreator : MonoBehaviour { [MenuItem(\"Assets/Build Asset Bundle\")] static void BuildBundles () { if ( BuildPipeline . BuildAssetBundles ( \"Assets/AssetBundles\" , BuildAssetBundleOptions . None , BuildTarget . StandaloneWindows )) { print ( \"Successfully exported AssetBundles!\" ); } else { print ( \"Something went wrong!\" ); } } } #endif You should be able to find your assetbundle at this location: C:YourUnityProjectFolder\\Assets\\AssetBundles","title":"The AssetBundle"},{"location":"Slime_Rancher/SRML/CustomFood/getting_started/#inserting-the-assetbundle-into-visual-studio","text":"Then, insert your mesh/image into a folder (call it what you want, it dosen't matters), select a tag name at right-bottom and you now are able to export your mesh. Next, in your main class, add this line of code (remember to import adding it as reference, watch the requirements on how to do that) AssetBundle assetBundle = AssetBundle . LoadFromStream ( Assembly . GetExecutingAssembly (). GetManifestResourceStream ( typeof ( Main ), \"NAME OF BUNDLE\" )); And you loaded your assetbundle into visualstudio. At all time, if you want to grab something from it, write: assetBundle . LoadAsset < TargetType >( \"ASSET NAME\" ); Now you have 2 ways to create a food: The normal one (more performance/beginner friendly) The advanced one (have the full controll about your mesh, not really performance/beginner friendly) Good luck!","title":"Inserting the assetbundle into Visual Studio"},{"location":"Slime_Rancher/SRML/CustomFood/growable_plants/","text":"Note Thanks a lot to MegaPiggy for his huge help Requirements The getting started tutorial about slime rancher foods Creating custom Enums Setup Choose where you will place the code (if you readed all the previous tutorials then you will know what you exactly have to do, or place it in CustomFoodCreator or in another file/class/etc...) And it's time to read what we have to do and how we can do it. For easier tutorials, from now on I will explain every line as comment on the right What we are doing here can be applied to every other types of fruits, but for simplicity we will make 2 things plantable: GoldenGingers and Kookadobas, the one is a veggie and the other a fruit, let's see how to plant veggies (GoldenGinger): Veggies GameObject Prefab = PrefabUtils . CopyPrefab ( SRSingleton < GameContext >. Instance . LookupDirector . GetResourcePrefab ( SpawnResource . Id . CARROT_PATCH )); //The carrot plant when you plant it, that's what we are going to modify Prefab . name = \"patchGardenGinger\" ; //\"give it an name\" SpawnResource spawn = Prefab . GetComponent < SpawnResource >(); spawn . id = SpawnResource . Id . GINGER_PATCH ; //The SpawnResource.Id spawn . ObjectsToSpawn = SRSingleton < GameContext >. Instance . LookupDirector . GetPrefabs ( Identifiable . Id . PARSNIP_VEGGIE ); //What it will spawn spawn . BonusObjectsToSpawn = SRSingleton < GameContext >. Instance . LookupDirector . GetPrefabs ( Identifiable . Id . GINGER_VEGGIE ); //What it will spawn with a rare chance, here our GoldenGinger, we're avoiding getting OP items in a too quick way, so many veggies will be Parsnip and if you're lucky some will be a GoldenGinger spawn . MaxObjectsSpawned = 20 ; //How many can spawn, the max spawn . MinObjectsSpawned = 15 ; //how many can spawn, the min spawn . MinNutrientObjectsSpawned = spawn . MaxObjectsSpawned ; //??? spawn . MinSpawnIntervalGameHours = 18 ; //After how many minutes some veggies will start spawning, the min (that means that after 18 minutes the first veggies will be fully grown up and ready to be harvested) spawn . MaxSpawnIntervalGameHours = 24 ; //After how many minutes some veggies will start spawning, the max (after 24 minutes all veggies will be ready, it's the maximum of time) spawn . BonusChance = 0.1f ; //The chance of getting the rare veggie spawn . minBonusSelections = 2 ; //How many rare veggies can min spawn if you're lucky //Parsnip and Ginger Meshes and Materials are something you'll have to take from their identifiable prefab foreach ( GameObject sprout in Prefab . FindChildren ( \"Sprout\" )) //For every sprout gameobject { GameObject ParsnipGameObject = SRSingleton < GameContext >. Instance . LookupDirector . GetPrefab ( Identifiable . Id . PARSNIP_VEGGIE ). FindChildWithPartialName ( \"model_\" , false ); sprout . GetComponent < MeshFilter >(). sharedMesh = ParsnipGameObject . GetComponent < MeshFilter >(). sharedMesh ;; //Change the mesh sprout . GetComponent < MeshRenderer >(). sharedMaterial = ParsnipGameObject . GetComponent < MeshRenderer >(). sharedMaterial ;; //Change the material } foreach ( Joint joint in spawn . SpawnJoints ) //Same things, but now with the spawn joints, basically the actual veggie you will see grow { GameObject GingerGameObject = SRSingleton < GameContext >. Instance . LookupDirector . GetPrefab ( Identifiable . Id . GINGER_VEGGIE ). FindChildWithPartialName ( \"model_\" , false ); joint . gameObject . GetComponent < MeshFilter >(). sharedMesh = GingerGameObject . GetComponent < MeshFilter >(). sharedMesh ;; //Change the mesh joint . gameObject . GetComponent < MeshRenderer >(). sharedMaterial = GingerGameObject . GetComponent < MeshRenderer >(). sharedMaterial ;; //Change the material } Note how there exists an deluxe version (when you have the deluxe upgrade from Ogden), the ids/enums are the same only that you add an _DLX . For example, in the line PrefabUtils.CopyPrefab(SRSingleton<GameContext>.Instance.LookupDirector.GetResourcePrefab(SpawnResource.Id.CARROT_PATCH)) , instead of CARROT_PATCH you can write CARROT_PATCH_DLX Let's see how to do that! Deluxe So, for the deluxe version, you have to replace those lines: GameObject Prefab = PrefabUtils . CopyPrefab ( SRSingleton < GameContext >. Instance . LookupDirector . GetResourcePrefab ( SpawnResource . Id . CARROT_PATCH )); Prefab . name = \"patchGardenGinger\" ; spawn . id = SpawnResource . Id . GINGER_PATCH ; spawn . MaxObjectsSpawned = 20 ; spawn . MinObjectsSpawned = 15 ; spawn . minBonusSelections = 2 ; with those lines: GameObject Prefab = PrefabUtils . CopyPrefab ( SRSingleton < GameContext >. Instance . LookupDirector . GetResourcePrefab ( SpawnResource . Id . CARROT_PATCH_DLX )); Prefab . name = \"patchGardenGingerDlx\" ; spawn . id = SpawnResource . Id . GINGER_PATCH_DLX ; spawn . MaxObjectsSpawned = 30 ; spawn . MinObjectsSpawned = 23 ; spawn . minBonusSelections = 4 ; See easy to do! Fruit Now it's time to see how to make things grow on trees, the Kookadoba part: GameObject gameObject = PrefabUtils . CopyPrefab ( SRSingleton < GameContext >. Instance . LookupDirector . GetResourcePrefab ( SpawnResource . Id . LEMON_TREE )); gameObject . transform . position -= new Vector3 ( 0f , 15.5f , 0f ); gameObject . name = \"patchGardenKookadoba\" ; SpawnResource component = gameObject . GetComponent < SpawnResource >(); component . id = CustomEnum ; //An custom SpawnResource.Id for your Kookadoba,read the tutorial about Enums (note, SpawnResource.Id, NOT Identifiable.Id) component . ObjectsToSpawn = new GameObject [] { SRSingleton < GameContext >. Instance . LookupDirector . GetPrefab ( Identifiable . Id . KOOKADOBA_FRUIT ) }; component . BonusObjectsToSpawn = new GameObject [] { SRSingleton < GameContext >. Instance . LookupDirector . GetPrefab ( Identifiable . Id . KOOKADOBA_FRUIT ) }; component . MaxObjectsSpawned = 20f ; component . MinObjectsSpawned = 15f ; component . MinNutrientObjectsSpawned = component . MaxObjectsSpawned ; component . MinSpawnIntervalGameHours = 18f ; component . MaxSpawnIntervalGameHours = 24f ; component . BonusChance = 0.1f ; component . minBonusSelections = 2 ; foreach ( GameObject gameObject3 in gameObject . FindChildren ( \"Sprout\" , false )) { GameObject gameObject4 = SRSingleton < GameContext >. Instance . LookupDirector . GetPrefab ( Identifiable . Id . KOOKADOBA_FRUIT ). FindChildWithPartialName ( \"model_\" , false ); gameObject3 . GetComponent < MeshFilter >(). sharedMesh = gameObject4 . GetComponent < MeshFilter >(). sharedMesh ; gameObject3 . GetComponent < MeshRenderer >(). sharedMaterial = gameObject4 . GetComponent < MeshRenderer >(). sharedMaterial ; } foreach ( Joint joint in component . SpawnJoints ) { GameObject gameObject5 = SRSingleton < GameContext >. Instance . LookupDirector . GetPrefab ( Identifiable . Id . KOOKADOBA_FRUIT ). FindChildWithPartialName ( \"model_\" , false ); joint . gameObject . GetComponent < MeshFilter >(). sharedMesh = gameObject5 . GetComponent < MeshFilter >(). sharedMesh ; joint . gameObject . GetComponent < MeshRenderer >(). sharedMaterial = gameObject5 . GetComponent < MeshRenderer >(). sharedMaterial ; } As you can see: GameObject gameObject = PrefabUtils . CopyPrefab ( SRSingleton < GameContext >. Instance . LookupDirector . GetResourcePrefab ( SpawnResource . Id . LEMON_TREE )); We are using the PhaseLemon tree to make our kookadoba grow on. You can use whatever tree is inside the game Else, note how it's nearly identical to the veggie part, except for the sprouts and spawn joints Deluxe And same as for the veggies, here's the deluxe version. So, you have to replace those lines: GameObject Prefab = PrefabUtils . CopyPrefab ( SRSingleton < GameContext >. Instance . LookupDirector . GetResourcePrefab ( SpawnResource . Id . LEMON_TREE )); Prefab . name = \"patchGardenKookadoba\" ; spawn . id = CustomEnum ; spawn . MaxObjectsSpawned = 30 ; spawn . MinObjectsSpawned = 23 ; spawn . minBonusSelections = 4 ; with those lines: GameObject Prefab = PrefabUtils . CopyPrefab ( SRSingleton < GameContext >. Instance . LookupDirector . GetResourcePrefab ( SpawnResource . Id . LEMON_TREE_DLX )); Prefab . name = \"patchGardenKookadobaDlx\" ; spawn . id = CustomDlxEnum ; //An custom SpawnResource.Id, only that you add \"_DLX\" at the end spawn . MaxObjectsSpawned = 30 ; spawn . MinObjectsSpawned = 23 ; spawn . minBonusSelections = 4 ; See easy to do, the same like the veggies! Registering So, at first you have to register them in the LookupRegistry: LookupRegistry . RegisterSpawnResource ( theNormalPrefab ); LookupRegistry . RegisterSpawnResource ( theDeluxePrefab ); So for the Ginger the Prefab is: GameObject Prefab = PrefabUtils.CopyPrefab(SRSingleton<GameContext>.Instance.LookupDirector.GetResourcePrefab(SpawnResource.Id.CARROT_PATCH)); For the Kookadoba it is: GameObject Prefab = PrefabUtils.CopyPrefab(SRSingleton<GameContext>.Instance.LookupDirector.GetResourcePrefab(SpawnResource.Id.LEMON_TREE)); Now you add them to garden catchers you create a GardenCatcher.PlantSlot: PlantSlotRegistry . RegisterPlantSlot ( new GardenCatcher . PlantSlot () { id = Identifiable . Id . GINGER_VEGGIE , deluxePlantedPrefab = theDeluxePrefab , plantedPrefab = theNormalPrefab }); Or in the case of Kookadoba: PlantSlotRegistry . RegisterPlantSlot ( new GardenCatcher . PlantSlot () { id = Identifiable . Id . KOOKADOBA_FRUIT , deluxePlantedPrefab = theDeluxePrefab , plantedPrefab = theNormalPrefab }); And you did it! You completed this tutorial! A quick remember: you can't make chickens grow, they work differently to fruits and veggies With that, you can continue with the next tutorial!","title":"Growable plants"},{"location":"Slime_Rancher/SRML/CustomFood/growable_plants/#requirements","text":"The getting started tutorial about slime rancher foods Creating custom Enums","title":"Requirements"},{"location":"Slime_Rancher/SRML/CustomFood/growable_plants/#setup","text":"Choose where you will place the code (if you readed all the previous tutorials then you will know what you exactly have to do, or place it in CustomFoodCreator or in another file/class/etc...) And it's time to read what we have to do and how we can do it. For easier tutorials, from now on I will explain every line as comment on the right What we are doing here can be applied to every other types of fruits, but for simplicity we will make 2 things plantable: GoldenGingers and Kookadobas, the one is a veggie and the other a fruit, let's see how to plant veggies (GoldenGinger):","title":"Setup"},{"location":"Slime_Rancher/SRML/CustomFood/growable_plants/#veggies","text":"GameObject Prefab = PrefabUtils . CopyPrefab ( SRSingleton < GameContext >. Instance . LookupDirector . GetResourcePrefab ( SpawnResource . Id . CARROT_PATCH )); //The carrot plant when you plant it, that's what we are going to modify Prefab . name = \"patchGardenGinger\" ; //\"give it an name\" SpawnResource spawn = Prefab . GetComponent < SpawnResource >(); spawn . id = SpawnResource . Id . GINGER_PATCH ; //The SpawnResource.Id spawn . ObjectsToSpawn = SRSingleton < GameContext >. Instance . LookupDirector . GetPrefabs ( Identifiable . Id . PARSNIP_VEGGIE ); //What it will spawn spawn . BonusObjectsToSpawn = SRSingleton < GameContext >. Instance . LookupDirector . GetPrefabs ( Identifiable . Id . GINGER_VEGGIE ); //What it will spawn with a rare chance, here our GoldenGinger, we're avoiding getting OP items in a too quick way, so many veggies will be Parsnip and if you're lucky some will be a GoldenGinger spawn . MaxObjectsSpawned = 20 ; //How many can spawn, the max spawn . MinObjectsSpawned = 15 ; //how many can spawn, the min spawn . MinNutrientObjectsSpawned = spawn . MaxObjectsSpawned ; //??? spawn . MinSpawnIntervalGameHours = 18 ; //After how many minutes some veggies will start spawning, the min (that means that after 18 minutes the first veggies will be fully grown up and ready to be harvested) spawn . MaxSpawnIntervalGameHours = 24 ; //After how many minutes some veggies will start spawning, the max (after 24 minutes all veggies will be ready, it's the maximum of time) spawn . BonusChance = 0.1f ; //The chance of getting the rare veggie spawn . minBonusSelections = 2 ; //How many rare veggies can min spawn if you're lucky //Parsnip and Ginger Meshes and Materials are something you'll have to take from their identifiable prefab foreach ( GameObject sprout in Prefab . FindChildren ( \"Sprout\" )) //For every sprout gameobject { GameObject ParsnipGameObject = SRSingleton < GameContext >. Instance . LookupDirector . GetPrefab ( Identifiable . Id . PARSNIP_VEGGIE ). FindChildWithPartialName ( \"model_\" , false ); sprout . GetComponent < MeshFilter >(). sharedMesh = ParsnipGameObject . GetComponent < MeshFilter >(). sharedMesh ;; //Change the mesh sprout . GetComponent < MeshRenderer >(). sharedMaterial = ParsnipGameObject . GetComponent < MeshRenderer >(). sharedMaterial ;; //Change the material } foreach ( Joint joint in spawn . SpawnJoints ) //Same things, but now with the spawn joints, basically the actual veggie you will see grow { GameObject GingerGameObject = SRSingleton < GameContext >. Instance . LookupDirector . GetPrefab ( Identifiable . Id . GINGER_VEGGIE ). FindChildWithPartialName ( \"model_\" , false ); joint . gameObject . GetComponent < MeshFilter >(). sharedMesh = GingerGameObject . GetComponent < MeshFilter >(). sharedMesh ;; //Change the mesh joint . gameObject . GetComponent < MeshRenderer >(). sharedMaterial = GingerGameObject . GetComponent < MeshRenderer >(). sharedMaterial ;; //Change the material } Note how there exists an deluxe version (when you have the deluxe upgrade from Ogden), the ids/enums are the same only that you add an _DLX . For example, in the line PrefabUtils.CopyPrefab(SRSingleton<GameContext>.Instance.LookupDirector.GetResourcePrefab(SpawnResource.Id.CARROT_PATCH)) , instead of CARROT_PATCH you can write CARROT_PATCH_DLX Let's see how to do that!","title":"Veggies"},{"location":"Slime_Rancher/SRML/CustomFood/growable_plants/#deluxe","text":"So, for the deluxe version, you have to replace those lines: GameObject Prefab = PrefabUtils . CopyPrefab ( SRSingleton < GameContext >. Instance . LookupDirector . GetResourcePrefab ( SpawnResource . Id . CARROT_PATCH )); Prefab . name = \"patchGardenGinger\" ; spawn . id = SpawnResource . Id . GINGER_PATCH ; spawn . MaxObjectsSpawned = 20 ; spawn . MinObjectsSpawned = 15 ; spawn . minBonusSelections = 2 ; with those lines: GameObject Prefab = PrefabUtils . CopyPrefab ( SRSingleton < GameContext >. Instance . LookupDirector . GetResourcePrefab ( SpawnResource . Id . CARROT_PATCH_DLX )); Prefab . name = \"patchGardenGingerDlx\" ; spawn . id = SpawnResource . Id . GINGER_PATCH_DLX ; spawn . MaxObjectsSpawned = 30 ; spawn . MinObjectsSpawned = 23 ; spawn . minBonusSelections = 4 ; See easy to do!","title":"Deluxe"},{"location":"Slime_Rancher/SRML/CustomFood/growable_plants/#fruit","text":"Now it's time to see how to make things grow on trees, the Kookadoba part: GameObject gameObject = PrefabUtils . CopyPrefab ( SRSingleton < GameContext >. Instance . LookupDirector . GetResourcePrefab ( SpawnResource . Id . LEMON_TREE )); gameObject . transform . position -= new Vector3 ( 0f , 15.5f , 0f ); gameObject . name = \"patchGardenKookadoba\" ; SpawnResource component = gameObject . GetComponent < SpawnResource >(); component . id = CustomEnum ; //An custom SpawnResource.Id for your Kookadoba,read the tutorial about Enums (note, SpawnResource.Id, NOT Identifiable.Id) component . ObjectsToSpawn = new GameObject [] { SRSingleton < GameContext >. Instance . LookupDirector . GetPrefab ( Identifiable . Id . KOOKADOBA_FRUIT ) }; component . BonusObjectsToSpawn = new GameObject [] { SRSingleton < GameContext >. Instance . LookupDirector . GetPrefab ( Identifiable . Id . KOOKADOBA_FRUIT ) }; component . MaxObjectsSpawned = 20f ; component . MinObjectsSpawned = 15f ; component . MinNutrientObjectsSpawned = component . MaxObjectsSpawned ; component . MinSpawnIntervalGameHours = 18f ; component . MaxSpawnIntervalGameHours = 24f ; component . BonusChance = 0.1f ; component . minBonusSelections = 2 ; foreach ( GameObject gameObject3 in gameObject . FindChildren ( \"Sprout\" , false )) { GameObject gameObject4 = SRSingleton < GameContext >. Instance . LookupDirector . GetPrefab ( Identifiable . Id . KOOKADOBA_FRUIT ). FindChildWithPartialName ( \"model_\" , false ); gameObject3 . GetComponent < MeshFilter >(). sharedMesh = gameObject4 . GetComponent < MeshFilter >(). sharedMesh ; gameObject3 . GetComponent < MeshRenderer >(). sharedMaterial = gameObject4 . GetComponent < MeshRenderer >(). sharedMaterial ; } foreach ( Joint joint in component . SpawnJoints ) { GameObject gameObject5 = SRSingleton < GameContext >. Instance . LookupDirector . GetPrefab ( Identifiable . Id . KOOKADOBA_FRUIT ). FindChildWithPartialName ( \"model_\" , false ); joint . gameObject . GetComponent < MeshFilter >(). sharedMesh = gameObject5 . GetComponent < MeshFilter >(). sharedMesh ; joint . gameObject . GetComponent < MeshRenderer >(). sharedMaterial = gameObject5 . GetComponent < MeshRenderer >(). sharedMaterial ; } As you can see: GameObject gameObject = PrefabUtils . CopyPrefab ( SRSingleton < GameContext >. Instance . LookupDirector . GetResourcePrefab ( SpawnResource . Id . LEMON_TREE )); We are using the PhaseLemon tree to make our kookadoba grow on. You can use whatever tree is inside the game Else, note how it's nearly identical to the veggie part, except for the sprouts and spawn joints","title":"Fruit"},{"location":"Slime_Rancher/SRML/CustomFood/growable_plants/#deluxe_1","text":"And same as for the veggies, here's the deluxe version. So, you have to replace those lines: GameObject Prefab = PrefabUtils . CopyPrefab ( SRSingleton < GameContext >. Instance . LookupDirector . GetResourcePrefab ( SpawnResource . Id . LEMON_TREE )); Prefab . name = \"patchGardenKookadoba\" ; spawn . id = CustomEnum ; spawn . MaxObjectsSpawned = 30 ; spawn . MinObjectsSpawned = 23 ; spawn . minBonusSelections = 4 ; with those lines: GameObject Prefab = PrefabUtils . CopyPrefab ( SRSingleton < GameContext >. Instance . LookupDirector . GetResourcePrefab ( SpawnResource . Id . LEMON_TREE_DLX )); Prefab . name = \"patchGardenKookadobaDlx\" ; spawn . id = CustomDlxEnum ; //An custom SpawnResource.Id, only that you add \"_DLX\" at the end spawn . MaxObjectsSpawned = 30 ; spawn . MinObjectsSpawned = 23 ; spawn . minBonusSelections = 4 ; See easy to do, the same like the veggies!","title":"Deluxe"},{"location":"Slime_Rancher/SRML/CustomFood/growable_plants/#registering","text":"So, at first you have to register them in the LookupRegistry: LookupRegistry . RegisterSpawnResource ( theNormalPrefab ); LookupRegistry . RegisterSpawnResource ( theDeluxePrefab ); So for the Ginger the Prefab is: GameObject Prefab = PrefabUtils.CopyPrefab(SRSingleton<GameContext>.Instance.LookupDirector.GetResourcePrefab(SpawnResource.Id.CARROT_PATCH)); For the Kookadoba it is: GameObject Prefab = PrefabUtils.CopyPrefab(SRSingleton<GameContext>.Instance.LookupDirector.GetResourcePrefab(SpawnResource.Id.LEMON_TREE)); Now you add them to garden catchers you create a GardenCatcher.PlantSlot: PlantSlotRegistry . RegisterPlantSlot ( new GardenCatcher . PlantSlot () { id = Identifiable . Id . GINGER_VEGGIE , deluxePlantedPrefab = theDeluxePrefab , plantedPrefab = theNormalPrefab }); Or in the case of Kookadoba: PlantSlotRegistry . RegisterPlantSlot ( new GardenCatcher . PlantSlot () { id = Identifiable . Id . KOOKADOBA_FRUIT , deluxePlantedPrefab = theDeluxePrefab , plantedPrefab = theNormalPrefab }); And you did it! You completed this tutorial! A quick remember: you can't make chickens grow, they work differently to fruits and veggies With that, you can continue with the next tutorial!","title":"Registering"},{"location":"Slime_Rancher/SRML/CustomFood/normal_mesh/","text":"Warning There is a bug wich makes your food green, I am still trying to find the issue with the help of MegaPiggy . It is a shader problem, I will update the wiki asap Requirements The getting started tutorial about slime rancher foods Creating custom Enums Loading it into the game Create a new class, call it something (e.g. FoodCreator), and create a new function (call it what you want). Now, write into this function (you need to write using UnityEngine , else it won't work): GameObject Prefab = PrefabUtils . CopyPrefab ( SRSingleton < GameContext >. Instance . LookupDirector . GetPrefab ( Identifiable . Id . OCAOCA_VEGGIE )); //It can be everything, as long this is a fruit/vegetable GameObject AssetFood = YourMainClass . assetBundle . LoadAsset < GameObject >( \"NAME OF OBJECT HERE\" ); //Your mesh located into the assetbundle Prefab . name = name ; Prefab . GetComponent < Identifiable >(). id = YourCustomEnum ; GameObject MeshPart = Prefab . FindChildWithPartialName ( \"model_\" ); MeshPart . GetComponent < MeshFilter >(). sharedMesh = AssetFood . GetComponentInChildren < MeshFilter >(). sharedMesh ; MeshPart . GetComponent < MeshRenderer >(). sharedMaterials = AssetFood . GetComponentInChildren < MeshRenderer >(). sharedMaterials ; return Prefab ; Now, in Load or PostLoad , add these lines: LookupRegistry . RegisterIdentifiablePrefab ( YourObject ); Identifiable . FOOD_CLASS . Add ( YourCustomEnum ); Identifiable . NON_SLIMES_CLASS . Add ( YourCustomEnum ); And you have it! You can go into the game and spawn your food writing spawn yourfoodenum in the command bar (Crtl + tab).","title":"Warning"},{"location":"Slime_Rancher/SRML/CustomFood/normal_mesh/#warning","text":"There is a bug wich makes your food green, I am still trying to find the issue with the help of MegaPiggy . It is a shader problem, I will update the wiki asap","title":"Warning"},{"location":"Slime_Rancher/SRML/CustomFood/normal_mesh/#requirements","text":"The getting started tutorial about slime rancher foods Creating custom Enums","title":"Requirements"},{"location":"Slime_Rancher/SRML/CustomFood/normal_mesh/#loading-it-into-the-game","text":"Create a new class, call it something (e.g. FoodCreator), and create a new function (call it what you want). Now, write into this function (you need to write using UnityEngine , else it won't work): GameObject Prefab = PrefabUtils . CopyPrefab ( SRSingleton < GameContext >. Instance . LookupDirector . GetPrefab ( Identifiable . Id . OCAOCA_VEGGIE )); //It can be everything, as long this is a fruit/vegetable GameObject AssetFood = YourMainClass . assetBundle . LoadAsset < GameObject >( \"NAME OF OBJECT HERE\" ); //Your mesh located into the assetbundle Prefab . name = name ; Prefab . GetComponent < Identifiable >(). id = YourCustomEnum ; GameObject MeshPart = Prefab . FindChildWithPartialName ( \"model_\" ); MeshPart . GetComponent < MeshFilter >(). sharedMesh = AssetFood . GetComponentInChildren < MeshFilter >(). sharedMesh ; MeshPart . GetComponent < MeshRenderer >(). sharedMaterials = AssetFood . GetComponentInChildren < MeshRenderer >(). sharedMaterials ; return Prefab ; Now, in Load or PostLoad , add these lines: LookupRegistry . RegisterIdentifiablePrefab ( YourObject ); Identifiable . FOOD_CLASS . Add ( YourCustomEnum ); Identifiable . NON_SLIMES_CLASS . Add ( YourCustomEnum ); And you have it! You can go into the game and spawn your food writing spawn yourfoodenum in the command bar (Crtl + tab).","title":"Loading it into the game"},{"location":"Slime_Rancher/SRML/CustomItems/custom_item_and_gadget/","text":"Requirements The getting started introduction about what you will find and have to do How to create your custom item Modding Hello again! Hope you are enjoying your item! But now, time to get on work again: Today you will learn how to make your item spawn thanks extractors, what are you waiting, let's start! At first we need the Extractor Component (Unity components), to get it you can do this (write everything in the Load function): Extractor component = SRSingleton<GameContext>.Instance.LookupDirector.GetGadgetDefinition(Gadget.Id.EXTRACTOR_PUMP_ABYSSAL).prefab.GetComponent<Extractor>(); Note that there are several extractors, like the drill and apiary, and how there are several levels of the\u00f9 (novice, advanced, master, Titan for the rill / Royal for the Apiary / Abyssal for the pump). It will make a huge difference the level of the extractor, so keep both those informations in mind! Now we need to create an Extractor.ProduceEntry : Extractor . ProduceEntry item = new Extractor . ProduceEntry { id = CUSTOM_ENUM_OF_ITEM_TO_PRODUCE , weight = 10f , //the luck/probability you have to get it, here it's 10% zone = ZoneDirector . Zone . RANCH , //The zone where you can get it, you can only get it there if 'restrictZone' is true restrictZone = true , //if you can get something in a particular zone spawnFX = component . produces [ 5 ]. spawnFX //The effects that comes once your item gets extracted (particles) }; That's pretty good, time to add this to the list, where there are all the other things you can extract: List < Extractor . ProduceEntry > list3 = new List < Extractor . ProduceEntry >(); //Create a new list foreach ( Extractor . ProduceEntry item2 in component . produces ) //For each thing it produces { list3 . Add ( item2 ); //Add it to the list } list3 . Add ( item ); //Add your custom 'Extractor.ProduceEntry' to the list component . produces = list3 . ToArray (); //Set the new list Believe me or not, that's all! Next tutorials are in coming, time to go test out your item!","title":"Requirements"},{"location":"Slime_Rancher/SRML/CustomItems/custom_item_and_gadget/#requirements","text":"The getting started introduction about what you will find and have to do How to create your custom item","title":"Requirements"},{"location":"Slime_Rancher/SRML/CustomItems/custom_item_and_gadget/#modding","text":"Hello again! Hope you are enjoying your item! But now, time to get on work again: Today you will learn how to make your item spawn thanks extractors, what are you waiting, let's start! At first we need the Extractor Component (Unity components), to get it you can do this (write everything in the Load function): Extractor component = SRSingleton<GameContext>.Instance.LookupDirector.GetGadgetDefinition(Gadget.Id.EXTRACTOR_PUMP_ABYSSAL).prefab.GetComponent<Extractor>(); Note that there are several extractors, like the drill and apiary, and how there are several levels of the\u00f9 (novice, advanced, master, Titan for the rill / Royal for the Apiary / Abyssal for the pump). It will make a huge difference the level of the extractor, so keep both those informations in mind! Now we need to create an Extractor.ProduceEntry : Extractor . ProduceEntry item = new Extractor . ProduceEntry { id = CUSTOM_ENUM_OF_ITEM_TO_PRODUCE , weight = 10f , //the luck/probability you have to get it, here it's 10% zone = ZoneDirector . Zone . RANCH , //The zone where you can get it, you can only get it there if 'restrictZone' is true restrictZone = true , //if you can get something in a particular zone spawnFX = component . produces [ 5 ]. spawnFX //The effects that comes once your item gets extracted (particles) }; That's pretty good, time to add this to the list, where there are all the other things you can extract: List < Extractor . ProduceEntry > list3 = new List < Extractor . ProduceEntry >(); //Create a new list foreach ( Extractor . ProduceEntry item2 in component . produces ) //For each thing it produces { list3 . Add ( item2 ); //Add it to the list } list3 . Add ( item ); //Add your custom 'Extractor.ProduceEntry' to the list component . produces = list3 . ToArray (); //Set the new list Believe me or not, that's all! Next tutorials are in coming, time to go test out your item!","title":"Modding"},{"location":"Slime_Rancher/SRML/CustomItems/custom_science_item/","text":"Requirements The getting started introduction about what you will find and have to do Creating custom Enums Modding Well, you are here for a custom item, right? Let's start then! At first we have to choice the model: because that's at the moment one of the only things we know how to modify, we will modify the primordy oil and make it our custom item! Create an custom Identifiable.Id Enum in your Ids class (if you readed the Enums tutorial you know what you have to do, else go read it first). Now that you have it, let's start creating it! Model Let's go into the Load function, copy the primordy oil and change some of it's settings: GameObject gameObject = PrefabUtils . CopyPrefab ( SRSingleton < GameContext >. Instance . LookupDirector . GetPrefab ( Identifiable . Id . PRIMORDY_OIL_CRAFT )); gameObject . GetComponent < Identifiable >(). id = CUSTOM_ID ; gameObject . name = \"resource {Name of the Item here, remember to remove the curly brackets/braces}\" ; Nice! We copied it and changed it's Id and name. Time to change the colors: gameObject . transform . GetChild ( 0 ). GetChild ( 1 ). GetChild ( 0 ). gameObject . GetComponent < MeshRenderer >(). material = SomeMaterial ; gameObject . transform . GetChild ( 0 ). gameObject . GetComponent < MeshRenderer >(). material = SomeMaterial ; Now here it get's tricky. At the moment we will see if there's a way to change the color without using custom materials (with custom I mean that you need to use Unity and Assetbundles), so maybe don't modify it for now. All what we want is to create a custom science item, right? Details can wait for the moment. Last for the Load function, but not least, it's time to register the whole! LookupRegistry . RegisterIdentifiablePrefab ( gameObject ); AmmoRegistry . RegisterAmmoPrefab ( PlayerState . AmmoMode . DEFAULT , SRSingleton < GameContext >. Instance . LookupDirector . GetPrefab ( YourId )); LookupRegistry . RegisterVacEntry ( YurId , SomeColor , SomeIcon ); GameObject prefab = SRSingleton < GameContext >. Instance . LookupDirector . GetPrefab ( YourId ); prefab . GetComponent < Vacuumable >(). size = Vacuumable . Size . NORMAL ; Now let's move to the PreLoad to register there the translations and etc. Before doing this, create a new PediaDirector.Id . TranslationPatcher . AddActorTranslation ( \"l.\" + YourCustomId . ToString (). ToLower (), \"INSERT NAME HERE\" ); PediaRegistry . RegisterIdentifiableMapping ( YourCustomPediaId , YourCustomId ); PediaRegistry . SetPediaCategory ( YourCustomPediaId , SRML . SR . PediaRegistry . PediaCategory . RESOURCES ); new SlimePediaEntryTranslation ( YourCustomPediaId ). SetTitleTranslation ( \"NAME OF YOUR ITEM\" ). SetIntroTranslation ( \"SOME SENTENCE\" ); Finally, we arrived on the other side of this tunnel! Tutorial completed aswell, now you probably want a way to get your resource , you should do that tutorial aswell. Good job and enjoy your item! Side Note If you want to choose something else, you can: Primordy oil was just an example. The problem is that it's unknown for yet how to change the colors of e.g. royal jelly, while it's known for primordy oil, deep brine and all those bottle resources.","title":"Requirements"},{"location":"Slime_Rancher/SRML/CustomItems/custom_science_item/#requirements","text":"The getting started introduction about what you will find and have to do Creating custom Enums","title":"Requirements"},{"location":"Slime_Rancher/SRML/CustomItems/custom_science_item/#modding","text":"Well, you are here for a custom item, right? Let's start then! At first we have to choice the model: because that's at the moment one of the only things we know how to modify, we will modify the primordy oil and make it our custom item! Create an custom Identifiable.Id Enum in your Ids class (if you readed the Enums tutorial you know what you have to do, else go read it first). Now that you have it, let's start creating it!","title":"Modding"},{"location":"Slime_Rancher/SRML/CustomItems/custom_science_item/#model","text":"Let's go into the Load function, copy the primordy oil and change some of it's settings: GameObject gameObject = PrefabUtils . CopyPrefab ( SRSingleton < GameContext >. Instance . LookupDirector . GetPrefab ( Identifiable . Id . PRIMORDY_OIL_CRAFT )); gameObject . GetComponent < Identifiable >(). id = CUSTOM_ID ; gameObject . name = \"resource {Name of the Item here, remember to remove the curly brackets/braces}\" ; Nice! We copied it and changed it's Id and name. Time to change the colors: gameObject . transform . GetChild ( 0 ). GetChild ( 1 ). GetChild ( 0 ). gameObject . GetComponent < MeshRenderer >(). material = SomeMaterial ; gameObject . transform . GetChild ( 0 ). gameObject . GetComponent < MeshRenderer >(). material = SomeMaterial ; Now here it get's tricky. At the moment we will see if there's a way to change the color without using custom materials (with custom I mean that you need to use Unity and Assetbundles), so maybe don't modify it for now. All what we want is to create a custom science item, right? Details can wait for the moment. Last for the Load function, but not least, it's time to register the whole! LookupRegistry . RegisterIdentifiablePrefab ( gameObject ); AmmoRegistry . RegisterAmmoPrefab ( PlayerState . AmmoMode . DEFAULT , SRSingleton < GameContext >. Instance . LookupDirector . GetPrefab ( YourId )); LookupRegistry . RegisterVacEntry ( YurId , SomeColor , SomeIcon ); GameObject prefab = SRSingleton < GameContext >. Instance . LookupDirector . GetPrefab ( YourId ); prefab . GetComponent < Vacuumable >(). size = Vacuumable . Size . NORMAL ; Now let's move to the PreLoad to register there the translations and etc. Before doing this, create a new PediaDirector.Id . TranslationPatcher . AddActorTranslation ( \"l.\" + YourCustomId . ToString (). ToLower (), \"INSERT NAME HERE\" ); PediaRegistry . RegisterIdentifiableMapping ( YourCustomPediaId , YourCustomId ); PediaRegistry . SetPediaCategory ( YourCustomPediaId , SRML . SR . PediaRegistry . PediaCategory . RESOURCES ); new SlimePediaEntryTranslation ( YourCustomPediaId ). SetTitleTranslation ( \"NAME OF YOUR ITEM\" ). SetIntroTranslation ( \"SOME SENTENCE\" ); Finally, we arrived on the other side of this tunnel! Tutorial completed aswell, now you probably want a way to get your resource , you should do that tutorial aswell. Good job and enjoy your item!","title":"Model"},{"location":"Slime_Rancher/SRML/CustomItems/custom_science_item/#side-note","text":"If you want to choose something else, you can: Primordy oil was just an example. The problem is that it's unknown for yet how to change the colors of e.g. royal jelly, while it's known for primordy oil, deep brine and all those bottle resources.","title":"Side Note"},{"location":"Slime_Rancher/SRML/CustomItems/getting_started/","text":"Note All the informations come from Lionmeow , a huge thanks What and how will this work? Well, first of all, what you are going to learn is how to: Create an custom science item Make it spawn using Extractors (e.g. make it spawn using a drill/pump) Make the slime reacts to your custom item Just a small introduction, good luck and happy modding!","title":"Getting started"},{"location":"Slime_Rancher/SRML/CustomItems/getting_started/#what-and-how-will-this-work","text":"Well, first of all, what you are going to learn is how to: Create an custom science item Make it spawn using Extractors (e.g. make it spawn using a drill/pump) Make the slime reacts to your custom item Just a small introduction, good luck and happy modding!","title":"What and how will this work?"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_appearance/","text":"Quote Third and finally, we have the appearance of the slime. really, now that I think about it, it's all just defining stuff. though this is the most complicated part. Lionmeow Well, this is the most long part, so don't worry if you don't understand everything. So, let's finish this last section! Code example SlimeAppearance slimeAppearance = ( SlimeAppearance ) PrefabUtils . DeepCopyObject ( pinkSlimeDefinition . AppearancesDefault [ 0 ]); slimeDefinition . AppearancesDefault [ 0 ] = slimeAppearance ; SlimeAppearanceStructure [] structures = slimeAppearance . Structures ; foreach ( SlimeAppearanceStructure slimeAppearanceStructure in structures ) { Material [] defaultMaterials = slimeAppearanceStructure . DefaultMaterials ; if ( defaultMaterials != null && defaultMaterials . Length != 0 ) { Material material = UnityEngine . Object . Instantiate ( SRSingleton < GameContext >. Instance . SlimeDefinitions . GetSlimeByIdentifiableId ( Identifiable . Id . PINK_SLIME ). AppearancesDefault [ 0 ]. Structures [ 0 ]. DefaultMaterials [ 0 ]); material . SetColor ( \"_TopColor\" , new Color32 ( 190 , 28 , 255 , 255 )); material . SetColor ( \"_MiddleColor\" , new Color32 ( 159 , 28 , 255 , 255 )); material . SetColor ( \"_BottomColor\" , new Color32 ( 120 , 28 , 255 , 255 )); material . SetColor ( \"_SpecColor\" , new Color32 ( 205 , 28 , 255 , 255 )); material . SetFloat ( \"_Shininess\" , 1f ); material . SetFloat ( \"_Gloss\" , 1f ); slimeAppearanceStructure . DefaultMaterials [ 0 ] = material ; } } SlimeExpressionFace [] expressionFaces = slimeAppearance . Face . ExpressionFaces ; for ( int k = 0 ; k < expressionFaces . Length ; k ++) { SlimeExpressionFace slimeExpressionFace = expressionFaces [ k ]; if (( bool ) slimeExpressionFace . Mouth ) { slimeExpressionFace . Mouth . SetColor ( \"_MouthBot\" , new Color32 ( 205 , 190 , 255 , 255 )); slimeExpressionFace . Mouth . SetColor ( \"_MouthMid\" , new Color32 ( 182 , 170 , 226 , 255 )); slimeExpressionFace . Mouth . SetColor ( \"_MouthTop\" , new Color32 ( 182 , 170 , 205 , 255 )); } if (( bool ) slimeExpressionFace . Eyes ) { slimeExpressionFace . Eyes . SetColor ( \"_EyeRed\" , new Color32 ( 205 , 190 , 255 , 255 )); slimeExpressionFace . Eyes . SetColor ( \"_EyeGreen\" , new Color32 ( 182 , 170 , 226 , 255 )); slimeExpressionFace . Eyes . SetColor ( \"_EyeBlue\" , new Color32 ( 182 , 170 , 205 , 255 )); } } slimeAppearance . Face . OnEnable (); slimeAppearance . ColorPalette = new SlimeAppearance . Palette { Top = new Color32 ( 159 , 28 , 255 , 255 ), Middle = new Color32 ( 120 , 28 , 255 , 255 ), Bottom = new Color32 ( 190 , 28 , 255 , 255 ) }; slimeObject . GetComponent < SlimeAppearanceApplicator >(). Appearance = slimeAppearance ; > We start out by making a copy of the pink slime's slime appearance. This is the other time we're using the pink slime's definition. If you want the slime to look like another slime, you'd need to copy a different slime's slime appearance. We set our slime's slime definition's appearance to this new appearance. Next, we grab the slime's structures and mess with its materials. Inside of the if statement inside the foreach loop is where we are messing with the material. The first line is what the material we're modifying is, in this case we're modifying the pink slime's material for our slime. We set the top middle and bottom colors, we set its spec color (which is the color of the shine), and we set how shiny and glossy the slime is. Skipping ahead to the for loop, this is where we're modifying the face's colors. It's pretty self-explanatory, just changing the colors of the various face structures. skipping down to modifying the slime's color palette, this is the color used for the slime's splat. Just like modifying the body colors, it's just the bottom middle and top colors again. Finally, we just set the slime's gameobject's SlimeAppearanceApplicator component's slime appearance to the appearance you just made. > Lionmeow Wow, it's a huge code. We should start now! First Line SlimeAppearance slimeAppearance = (SlimeAppearance)PrefabUtils.DeepCopyObject(pinkSlimeDefinition.AppearancesDefault[0]); Copying the slime appearance of the pink slime Second Line slimeDefinition.AppearancesDefault[0] = slimeAppearance; Assign the slime appearance to our slime definition Third Line SlimeAppearanceStructure[] structures = slimeAppearance.Structures; Getting the structures of the slime (they are like the 3D bones) Fourth Line foreach (SlimeAppearanceStructure slimeAppearanceStructure in structures) For each structure (for each bone) Fifth Line Material[] defaultMaterials = slimeAppearanceStructure.DefaultMaterials; Getting the materials of the structure (of the bone) Sixth Line if (defaultMaterials != null && defaultMaterials.Length != 0) If the structure/bone is not null (if it exists) and if it's length is not 0 (if it exists and it contains something), then continue with the lines below Seventh Line Material material = UnityEngine.Object.Instantiate(SRSingleton<GameContext>.Instance.SlimeDefinitions.GetSlimeByIdentifiableId(Identifiable.Id.PINK_SLIME).AppearancesDefault[0].Structures[0].DefaultMaterials[0]); Creating + cloning the material of the pink slime From Eighth to Fourteenth Lines material . SetColor ( \"_TopColor\" , new Color32 ( 190 , 28 , 255 , 255 )); material . SetColor ( \"_MiddleColor\" , new Color32 ( 159 , 28 , 255 , 255 )); material . SetColor ( \"_BottomColor\" , new Color32 ( 120 , 28 , 255 , 255 )); material . SetColor ( \"_SpecColor\" , new Color32 ( 205 , 28 , 255 , 255 )); material . SetFloat ( \"_Shininess\" , 1f ); material . SetFloat ( \"_Gloss\" , 1f ); We are just defining the material (the colours, the shininess and etc...) MegaPiggy said some interesting facts about this: > All materials obviously have textures and colors that make them work. > Slime materials have many different color settings, but the 4 main ones are - Top - Middle - Bottom - Spec (used for the splats that happen when a slime hits something) > There are a few others but I don't mess with them (Rim and Outline) > There are also floats that effect the material that named Shininess, gloss and a few more that I can't think of. > But some slimes use a different material that doesn't have these settings. Like the twinkle, gold and ruins slimes Fifteenth Line slimeAppearanceStructure.DefaultMaterials[0] = material; Once we created our material, we need to assign it to our structure/bone. Sixteenth Line SlimeExpressionFace[] expressionFaces = slimeAppearance.Face.ExpressionFaces; Getting the faceparts of our pink slime Seventeenth Line for (int k = 0; k < expressionFaces.Length; k++) For each face part (k is the number of the face part we are currently there, it is a normal C# for-loop) Eighteenth Line SlimeExpressionFace slimeExpressionFace = expressionFaces[k]; Getting the face number k (just getting the correct face) Nineteenth Line if ((bool)slimeExpressionFace.Mouth) If the currently face part is a part of a mounth, then continue below From Twentieth to Twenty-second Lines slimeExpressionFace . Mouth . SetColor ( \"_MouthBot\" , new Color32 ( 205 , 190 , 255 , 255 )); slimeExpressionFace . Mouth . SetColor ( \"_MouthMid\" , new Color32 ( 182 , 170 , 226 , 255 )); slimeExpressionFace . Mouth . SetColor ( \"_MouthTop\" , new Color32 ( 182 , 170 , 205 , 255 )); If yes, then change the colours of the mounth Twenty-third Line if ((bool)slimeExpressionFace.Eyes) If the currently face part is a part of the eyes, then continue below Twenty-fourth Line slimeExpressionFace . Eyes . SetColor ( \"_EyeRed\" , new Color32 ( 205 , 190 , 255 , 255 )); slimeExpressionFace . Eyes . SetColor ( \"_EyeGreen\" , new Color32 ( 182 , 170 , 226 , 255 )); slimeExpressionFace . Eyes . SetColor ( \"_EyeBlue\" , new Color32 ( 182 , 170 , 205 , 255 )); If yes, then change the colours of the eyes Twenty-fifth Line slimeAppearance.Face.OnEnable(); No informations found From Twenty-sixth to Twenty-ninth Line slimeAppearance . ColorPalette = new SlimeAppearance . Palette { Top = new Color32 ( 159 , 28 , 255 , 255 ), Middle = new Color32 ( 120 , 28 , 255 , 255 ), Bottom = new Color32 ( 190 , 28 , 255 , 255 ) }; Changing the colour of the body of the slime Thirty slimeObject.GetComponent<SlimeAppearanceApplicator>().Appearance = slimeAppearance; Finally, we assign our created and modified slime appearance to our slime object Conclusion This is the most short code snippet, the next will talk about the final steps to do, wich will be the last part of our whole tutorial. Time to end the whole tutorial! You can find the final code in the tutorial's section Creating a constructor function Return to the main place","title":"Slime Appearance"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_appearance/#code-example","text":"SlimeAppearance slimeAppearance = ( SlimeAppearance ) PrefabUtils . DeepCopyObject ( pinkSlimeDefinition . AppearancesDefault [ 0 ]); slimeDefinition . AppearancesDefault [ 0 ] = slimeAppearance ; SlimeAppearanceStructure [] structures = slimeAppearance . Structures ; foreach ( SlimeAppearanceStructure slimeAppearanceStructure in structures ) { Material [] defaultMaterials = slimeAppearanceStructure . DefaultMaterials ; if ( defaultMaterials != null && defaultMaterials . Length != 0 ) { Material material = UnityEngine . Object . Instantiate ( SRSingleton < GameContext >. Instance . SlimeDefinitions . GetSlimeByIdentifiableId ( Identifiable . Id . PINK_SLIME ). AppearancesDefault [ 0 ]. Structures [ 0 ]. DefaultMaterials [ 0 ]); material . SetColor ( \"_TopColor\" , new Color32 ( 190 , 28 , 255 , 255 )); material . SetColor ( \"_MiddleColor\" , new Color32 ( 159 , 28 , 255 , 255 )); material . SetColor ( \"_BottomColor\" , new Color32 ( 120 , 28 , 255 , 255 )); material . SetColor ( \"_SpecColor\" , new Color32 ( 205 , 28 , 255 , 255 )); material . SetFloat ( \"_Shininess\" , 1f ); material . SetFloat ( \"_Gloss\" , 1f ); slimeAppearanceStructure . DefaultMaterials [ 0 ] = material ; } } SlimeExpressionFace [] expressionFaces = slimeAppearance . Face . ExpressionFaces ; for ( int k = 0 ; k < expressionFaces . Length ; k ++) { SlimeExpressionFace slimeExpressionFace = expressionFaces [ k ]; if (( bool ) slimeExpressionFace . Mouth ) { slimeExpressionFace . Mouth . SetColor ( \"_MouthBot\" , new Color32 ( 205 , 190 , 255 , 255 )); slimeExpressionFace . Mouth . SetColor ( \"_MouthMid\" , new Color32 ( 182 , 170 , 226 , 255 )); slimeExpressionFace . Mouth . SetColor ( \"_MouthTop\" , new Color32 ( 182 , 170 , 205 , 255 )); } if (( bool ) slimeExpressionFace . Eyes ) { slimeExpressionFace . Eyes . SetColor ( \"_EyeRed\" , new Color32 ( 205 , 190 , 255 , 255 )); slimeExpressionFace . Eyes . SetColor ( \"_EyeGreen\" , new Color32 ( 182 , 170 , 226 , 255 )); slimeExpressionFace . Eyes . SetColor ( \"_EyeBlue\" , new Color32 ( 182 , 170 , 205 , 255 )); } } slimeAppearance . Face . OnEnable (); slimeAppearance . ColorPalette = new SlimeAppearance . Palette { Top = new Color32 ( 159 , 28 , 255 , 255 ), Middle = new Color32 ( 120 , 28 , 255 , 255 ), Bottom = new Color32 ( 190 , 28 , 255 , 255 ) }; slimeObject . GetComponent < SlimeAppearanceApplicator >(). Appearance = slimeAppearance ; > We start out by making a copy of the pink slime's slime appearance. This is the other time we're using the pink slime's definition. If you want the slime to look like another slime, you'd need to copy a different slime's slime appearance. We set our slime's slime definition's appearance to this new appearance. Next, we grab the slime's structures and mess with its materials. Inside of the if statement inside the foreach loop is where we are messing with the material. The first line is what the material we're modifying is, in this case we're modifying the pink slime's material for our slime. We set the top middle and bottom colors, we set its spec color (which is the color of the shine), and we set how shiny and glossy the slime is. Skipping ahead to the for loop, this is where we're modifying the face's colors. It's pretty self-explanatory, just changing the colors of the various face structures. skipping down to modifying the slime's color palette, this is the color used for the slime's splat. Just like modifying the body colors, it's just the bottom middle and top colors again. Finally, we just set the slime's gameobject's SlimeAppearanceApplicator component's slime appearance to the appearance you just made. > Lionmeow Wow, it's a huge code. We should start now!","title":"Code example"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_appearance/#first-line","text":"SlimeAppearance slimeAppearance = (SlimeAppearance)PrefabUtils.DeepCopyObject(pinkSlimeDefinition.AppearancesDefault[0]); Copying the slime appearance of the pink slime","title":"First Line"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_appearance/#second-line","text":"slimeDefinition.AppearancesDefault[0] = slimeAppearance; Assign the slime appearance to our slime definition","title":"Second Line"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_appearance/#third-line","text":"SlimeAppearanceStructure[] structures = slimeAppearance.Structures; Getting the structures of the slime (they are like the 3D bones)","title":"Third Line"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_appearance/#fourth-line","text":"foreach (SlimeAppearanceStructure slimeAppearanceStructure in structures) For each structure (for each bone)","title":"Fourth Line"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_appearance/#fifth-line","text":"Material[] defaultMaterials = slimeAppearanceStructure.DefaultMaterials; Getting the materials of the structure (of the bone)","title":"Fifth Line"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_appearance/#sixth-line","text":"if (defaultMaterials != null && defaultMaterials.Length != 0) If the structure/bone is not null (if it exists) and if it's length is not 0 (if it exists and it contains something), then continue with the lines below","title":"Sixth Line"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_appearance/#seventh-line","text":"Material material = UnityEngine.Object.Instantiate(SRSingleton<GameContext>.Instance.SlimeDefinitions.GetSlimeByIdentifiableId(Identifiable.Id.PINK_SLIME).AppearancesDefault[0].Structures[0].DefaultMaterials[0]); Creating + cloning the material of the pink slime","title":"Seventh Line"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_appearance/#from-eighth-to-fourteenth-lines","text":"material . SetColor ( \"_TopColor\" , new Color32 ( 190 , 28 , 255 , 255 )); material . SetColor ( \"_MiddleColor\" , new Color32 ( 159 , 28 , 255 , 255 )); material . SetColor ( \"_BottomColor\" , new Color32 ( 120 , 28 , 255 , 255 )); material . SetColor ( \"_SpecColor\" , new Color32 ( 205 , 28 , 255 , 255 )); material . SetFloat ( \"_Shininess\" , 1f ); material . SetFloat ( \"_Gloss\" , 1f ); We are just defining the material (the colours, the shininess and etc...) MegaPiggy said some interesting facts about this: > All materials obviously have textures and colors that make them work. > Slime materials have many different color settings, but the 4 main ones are - Top - Middle - Bottom - Spec (used for the splats that happen when a slime hits something) > There are a few others but I don't mess with them (Rim and Outline) > There are also floats that effect the material that named Shininess, gloss and a few more that I can't think of. > But some slimes use a different material that doesn't have these settings. Like the twinkle, gold and ruins slimes","title":"From Eighth to Fourteenth Lines"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_appearance/#fifteenth-line","text":"slimeAppearanceStructure.DefaultMaterials[0] = material; Once we created our material, we need to assign it to our structure/bone.","title":"Fifteenth Line"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_appearance/#sixteenth-line","text":"SlimeExpressionFace[] expressionFaces = slimeAppearance.Face.ExpressionFaces; Getting the faceparts of our pink slime","title":"Sixteenth Line"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_appearance/#seventeenth-line","text":"for (int k = 0; k < expressionFaces.Length; k++) For each face part (k is the number of the face part we are currently there, it is a normal C# for-loop)","title":"Seventeenth Line"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_appearance/#eighteenth-line","text":"SlimeExpressionFace slimeExpressionFace = expressionFaces[k]; Getting the face number k (just getting the correct face)","title":"Eighteenth Line"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_appearance/#nineteenth-line","text":"if ((bool)slimeExpressionFace.Mouth) If the currently face part is a part of a mounth, then continue below","title":"Nineteenth Line"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_appearance/#from-twentieth-to-twenty-second-lines","text":"slimeExpressionFace . Mouth . SetColor ( \"_MouthBot\" , new Color32 ( 205 , 190 , 255 , 255 )); slimeExpressionFace . Mouth . SetColor ( \"_MouthMid\" , new Color32 ( 182 , 170 , 226 , 255 )); slimeExpressionFace . Mouth . SetColor ( \"_MouthTop\" , new Color32 ( 182 , 170 , 205 , 255 )); If yes, then change the colours of the mounth","title":"From Twentieth to Twenty-second Lines"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_appearance/#twenty-third-line","text":"if ((bool)slimeExpressionFace.Eyes) If the currently face part is a part of the eyes, then continue below","title":"Twenty-third Line"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_appearance/#twenty-fourth-line","text":"slimeExpressionFace . Eyes . SetColor ( \"_EyeRed\" , new Color32 ( 205 , 190 , 255 , 255 )); slimeExpressionFace . Eyes . SetColor ( \"_EyeGreen\" , new Color32 ( 182 , 170 , 226 , 255 )); slimeExpressionFace . Eyes . SetColor ( \"_EyeBlue\" , new Color32 ( 182 , 170 , 205 , 255 )); If yes, then change the colours of the eyes","title":"Twenty-fourth Line"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_appearance/#twenty-fifth-line","text":"slimeAppearance.Face.OnEnable(); No informations found","title":"Twenty-fifth Line"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_appearance/#from-twenty-sixth-to-twenty-ninth-line","text":"slimeAppearance . ColorPalette = new SlimeAppearance . Palette { Top = new Color32 ( 159 , 28 , 255 , 255 ), Middle = new Color32 ( 120 , 28 , 255 , 255 ), Bottom = new Color32 ( 190 , 28 , 255 , 255 ) }; Changing the colour of the body of the slime","title":"From Twenty-sixth to Twenty-ninth Line"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_appearance/#thirty","text":"slimeObject.GetComponent<SlimeAppearanceApplicator>().Appearance = slimeAppearance; Finally, we assign our created and modified slime appearance to our slime object","title":"Thirty"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_appearance/#conclusion","text":"This is the most short code snippet, the next will talk about the final steps to do, wich will be the last part of our whole tutorial. Time to end the whole tutorial! You can find the final code in the tutorial's section Creating a constructor function","title":"Conclusion"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_appearance/#return-to-the-main-place","text":"","title":"Return to the main place"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_definition/","text":"Slime Definition Quote Let's start with the slime definition. It's mainly just defining a lot of stuff that the slime needs to function, like its diet, its id, and some other variables. Lionmeow Well, let's start with it! Code example SlimeDefinition pinkSlimeDefinition = SRSingleton < GameContext >. Instance . SlimeDefinitions . GetSlimeByIdentifiableId ( Identifiable . Id . PINK_SLIME ); SlimeDefinition slimeDefinition = ( SlimeDefinition ) PrefabUtils . DeepCopyObject ( pinkSlimeDefinition ); slimeDefinition . AppearancesDefault = new SlimeAppearance [ 1 ]; slimeDefinition . Diet . Produces = new Identifiable . Id [ 1 ] { Id . SLIME_PLORT }; slimeDefinition . Diet . MajorFoodGroups = new SlimeEat . FoodGroup [ 1 ] { SlimeEat . FoodGroup . VEGGIES }; slimeDefinition . Diet . AdditionalFoods = new Identifiable . Id [ 0 ]; slimeDefinition . Diet . Favorites = new Identifiable . Id [ 1 ] { Identifiable . Id . CARROT_VEGGIE }; slimeDefinition . Diet . EatMap ?. Clear (); slimeDefinition . CanLargofy = false ; slimeDefinition . FavoriteToys = new Identifiable . Id [ 0 ]; slimeDefinition . Name = \"Slime Slime\" ; slimeDefinition . IdentifiableId = Id . SLIME_SLIME ; Breakdown > this code starts with just getting the pink slime's definition, we'll need this a few times. the first time we'll need this is directly after, where we're cloning it to be the definition of our first slime. then we just go through, we set appearancesdefault to a new list, this will be important later. the diet has a few components, what the slime produces, the foodgroups that it eats, the additional foods it can eat outside of the foodgroup, and its favorite foods. we also clear the eatmap because... we do. I set CanLargoify to false because I'm not making largos at the moment. favorite toys is obvious, just the favorite toys. the name of the slime, and finally its identifiable.id. like I said, this is mostly just defining stuff. > Lionmeow I wasn't kidding by warning it would be a huge code, let's analyze the whole: First Line SlimeDefinition pinkSlimeDefinition = SRSingleton<GameContext>.Instance.SlimeDefinitions.GetSlimeByIdentifiableId(Identifiable.Id.PINK_SLIME); SRSingleton<GameContext>.Instance We are getting the GameContext . SlimeDefinitions.GetSlimeByIdentifiableId Then we call the GetSlimeByIdentifiableId function from SlimeDefinitions (click here for more details) Second Line SlimeDefinition slimeDefinition = (SlimeDefinition)PrefabUtils.DeepCopyObject(pinkSlimeDefinition); We are copying the SlimeDefinition of the pink slime (to avoid to change the actual pink slime) Third Line slimeDefinition.AppearancesDefault = new SlimeAppearance[1]; Creating a new SlimeAppearance with the max lenght of 1 (The little [1] at the end indicates it us). Fourth Line slimeDefinition . Diet . Produces = new Identifiable . Id [ 1 ] { Identifiable . Id . GOLD_PLORT }; Making the slime produce gold plorts when he eats something (you may change this later to all kind of plorts that you want, even custom plorts) Fifth Line slimeDefinition . Diet . MajorFoodGroups = new SlimeEat . FoodGroup [ 1 ] { SlimeEat . FoodGroup . VEGGIES }; The FoodGroup that our slime can eat, there exists 5 FoodGroups (that the game code has): enum FoodGroup { FRUIT = 0 , VEGGIES = 1 , MEAT = 2 , NONTARRGOLD_SLIMES = 3 , PLORTS = 4 , GINGER = 5 } Sixth Line slimeDefinition.Diet.AdditionalFoods = new Identifiable.Id[0]; Adding additional food. Let's say your slime only eats fruit, but he eats, as exception, an ocaoca (wich is a veggie), then you would write there: slimeDefinition . Diet . AdditionalFoods = new Identifiable . Id [ 1 ]{ Identifiable . Id . OCAOCA_VEGGIE } Seventh Line slimeDefinition . Diet . Favorites = new Identifiable . Id [ 1 ] { Identifiable . Id . CARROT_VEGGIE }; The slime favorite food (you may be able to change it to all other food, remember that it depends of the fifth line, if you write there SlimeEat.FoodGroup.FRUIT instead of SlimeEat.FoodGroup.VEGGIES , then you have to write a fruit instead of a veggie) Eighth Line slimeDefinition.Diet.EatMap?.Clear(); No informations found Ninth Line slimeDefinition.CanLargofy = false; Avoid the slime to Largofy (at this moment there's no found way to largofy slimes, don't set this to true) Tenth Line slimeDefinition.FavoriteToys = new Identifiable.Id[0]; The favorite toy of your slime, for example: slimeDefinition . FavoriteToys = new Identifiable . Id [ 1 ] { Identifiable . Id . BEACH_BALL_TOY }; Eleventh Line slimeDefinition.Name = \"Slime Slime\"; Setting the name of your slime Twelfth Line slimeDefinition.IdentifiableId = Id.SLIME_SLIME; Setting the Id of your slime (you should create your own Id, it else won't work. If you don't know how to do it, click here ) Conclusion This is the second most long code snippet, the next will talk about the slime object , wich is much smaller. Time to read the two other sections on how to create your slime! You can find the final code in the tutorial's section Creating a constructor function Return to the main place","title":"Slime Definition"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_definition/#slime-definition","text":"Quote Let's start with the slime definition. It's mainly just defining a lot of stuff that the slime needs to function, like its diet, its id, and some other variables. Lionmeow Well, let's start with it!","title":"Slime Definition"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_definition/#code-example","text":"SlimeDefinition pinkSlimeDefinition = SRSingleton < GameContext >. Instance . SlimeDefinitions . GetSlimeByIdentifiableId ( Identifiable . Id . PINK_SLIME ); SlimeDefinition slimeDefinition = ( SlimeDefinition ) PrefabUtils . DeepCopyObject ( pinkSlimeDefinition ); slimeDefinition . AppearancesDefault = new SlimeAppearance [ 1 ]; slimeDefinition . Diet . Produces = new Identifiable . Id [ 1 ] { Id . SLIME_PLORT }; slimeDefinition . Diet . MajorFoodGroups = new SlimeEat . FoodGroup [ 1 ] { SlimeEat . FoodGroup . VEGGIES }; slimeDefinition . Diet . AdditionalFoods = new Identifiable . Id [ 0 ]; slimeDefinition . Diet . Favorites = new Identifiable . Id [ 1 ] { Identifiable . Id . CARROT_VEGGIE }; slimeDefinition . Diet . EatMap ?. Clear (); slimeDefinition . CanLargofy = false ; slimeDefinition . FavoriteToys = new Identifiable . Id [ 0 ]; slimeDefinition . Name = \"Slime Slime\" ; slimeDefinition . IdentifiableId = Id . SLIME_SLIME ;","title":"Code example"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_definition/#breakdown","text":"> this code starts with just getting the pink slime's definition, we'll need this a few times. the first time we'll need this is directly after, where we're cloning it to be the definition of our first slime. then we just go through, we set appearancesdefault to a new list, this will be important later. the diet has a few components, what the slime produces, the foodgroups that it eats, the additional foods it can eat outside of the foodgroup, and its favorite foods. we also clear the eatmap because... we do. I set CanLargoify to false because I'm not making largos at the moment. favorite toys is obvious, just the favorite toys. the name of the slime, and finally its identifiable.id. like I said, this is mostly just defining stuff. > Lionmeow I wasn't kidding by warning it would be a huge code, let's analyze the whole:","title":"Breakdown"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_definition/#first-line","text":"SlimeDefinition pinkSlimeDefinition = SRSingleton<GameContext>.Instance.SlimeDefinitions.GetSlimeByIdentifiableId(Identifiable.Id.PINK_SLIME); SRSingleton<GameContext>.Instance We are getting the GameContext . SlimeDefinitions.GetSlimeByIdentifiableId Then we call the GetSlimeByIdentifiableId function from SlimeDefinitions (click here for more details)","title":"First Line"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_definition/#second-line","text":"SlimeDefinition slimeDefinition = (SlimeDefinition)PrefabUtils.DeepCopyObject(pinkSlimeDefinition); We are copying the SlimeDefinition of the pink slime (to avoid to change the actual pink slime)","title":"Second Line"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_definition/#third-line","text":"slimeDefinition.AppearancesDefault = new SlimeAppearance[1]; Creating a new SlimeAppearance with the max lenght of 1 (The little [1] at the end indicates it us).","title":"Third Line"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_definition/#fourth-line","text":"slimeDefinition . Diet . Produces = new Identifiable . Id [ 1 ] { Identifiable . Id . GOLD_PLORT }; Making the slime produce gold plorts when he eats something (you may change this later to all kind of plorts that you want, even custom plorts)","title":"Fourth Line"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_definition/#fifth-line","text":"slimeDefinition . Diet . MajorFoodGroups = new SlimeEat . FoodGroup [ 1 ] { SlimeEat . FoodGroup . VEGGIES }; The FoodGroup that our slime can eat, there exists 5 FoodGroups (that the game code has): enum FoodGroup { FRUIT = 0 , VEGGIES = 1 , MEAT = 2 , NONTARRGOLD_SLIMES = 3 , PLORTS = 4 , GINGER = 5 }","title":"Fifth Line"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_definition/#sixth-line","text":"slimeDefinition.Diet.AdditionalFoods = new Identifiable.Id[0]; Adding additional food. Let's say your slime only eats fruit, but he eats, as exception, an ocaoca (wich is a veggie), then you would write there: slimeDefinition . Diet . AdditionalFoods = new Identifiable . Id [ 1 ]{ Identifiable . Id . OCAOCA_VEGGIE }","title":"Sixth Line"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_definition/#seventh-line","text":"slimeDefinition . Diet . Favorites = new Identifiable . Id [ 1 ] { Identifiable . Id . CARROT_VEGGIE }; The slime favorite food (you may be able to change it to all other food, remember that it depends of the fifth line, if you write there SlimeEat.FoodGroup.FRUIT instead of SlimeEat.FoodGroup.VEGGIES , then you have to write a fruit instead of a veggie)","title":"Seventh Line"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_definition/#eighth-line","text":"slimeDefinition.Diet.EatMap?.Clear(); No informations found","title":"Eighth Line"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_definition/#ninth-line","text":"slimeDefinition.CanLargofy = false; Avoid the slime to Largofy (at this moment there's no found way to largofy slimes, don't set this to true)","title":"Ninth Line"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_definition/#tenth-line","text":"slimeDefinition.FavoriteToys = new Identifiable.Id[0]; The favorite toy of your slime, for example: slimeDefinition . FavoriteToys = new Identifiable . Id [ 1 ] { Identifiable . Id . BEACH_BALL_TOY };","title":"Tenth Line"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_definition/#eleventh-line","text":"slimeDefinition.Name = \"Slime Slime\"; Setting the name of your slime","title":"Eleventh Line"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_definition/#twelfth-line","text":"slimeDefinition.IdentifiableId = Id.SLIME_SLIME; Setting the Id of your slime (you should create your own Id, it else won't work. If you don't know how to do it, click here )","title":"Twelfth  Line"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_definition/#conclusion","text":"This is the second most long code snippet, the next will talk about the slime object , wich is much smaller. Time to read the two other sections on how to create your slime! You can find the final code in the tutorial's section Creating a constructor function","title":"Conclusion"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_definition/#return-to-the-main-place","text":"","title":"Return to the main place"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_object/","text":"Slime Object Quote Next, with the slime's object. Similarly, this will be mostly just defining stuff. Lionmeow It's a bit better than the slime definition, it's just defining stuff. Code example GameObject slimeObject = PrefabUtils . CopyPrefab ( SRSingleton < GameContext >. Instance . LookupDirector . GetPrefab ( Identifiable . Id . PINK_SLIME )); slimeObject . name = \"slimeSlime\" ; slimeObject . GetComponent < PlayWithToys >(). slimeDefinition = slimeDefinition ; slimeObject . GetComponent < SlimeAppearanceApplicator >(). SlimeDefinition = slimeDefinition ; slimeObject . GetComponent < SlimeEat >(). slimeDefinition = slimeDefinition ; slimeObject . GetComponent < Identifiable >(). id = Id . SLIME_SLIME ; UnityEngine . Object . Destroy ( slimeObject . GetComponent < PinkSlimeFoodTypeTracker >()); Quote The first line is just copying the pink slime's gameobject, similar to what we did with the slime definition. We now name the object. The naming convention is 'slime' followed by the name of the slime. So if the slime was a digital slime than it would be named slimeDigital. We then just make sure the slime definition of a few components are set to the right one, PlayWithToys, SlimeAppearanceApplicator, SlimeEat. We set its identifiable.id, and finally, we remove the PinkSlimeFoodTypeTracker from it because if we didn't then that'd track progress towards that one pink slime achievement.** Lionmeow As promised, it is not as long the slime definition, is that not great? First Line GameObject slimeObject = PrefabUtils.CopyPrefab(SRSingleton<GameContext>.Instance.LookupDirector.GetPrefab(Identifiable.Id.PINK_SLIME)); Copying the GameObject of a normal pink slime. Second Line slimeObject.name = \"slimeSlime\"; Setting the name. Third-Fifth Line slimeObject.GetComponent<PlayWithToys>().slimeDefinition = slimeDefinition; We are getting the Component of type PlayWithToy, getting it's slimeDefinition and setting our definition there. The same for the fourth and fifth lines (only that we get other components). Sixth Line slimeObject.GetComponent<Identifiable>().id = Id.SLIME_SLIME; Setting the id of the slime object to our custom id (it need to be your id). Seventh Line UnityEngine.Object.Destroy(slimeObject.GetComponent<PinkSlimeFoodTypeTracker>()); Destroying the PinkSlimeFoodTypeTracker Component of our slime object because if we didn't then that'd track progress towards that one pink slime achievement (we don't want it) Conclusion This is the most short code snippet, the next will talk about the slime appearance , wich is much larger. Time to read the last section on how to create your slime! You can find the final code in the tutorial's section Creating a constructor function Return to the main place","title":"Slime Object"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_object/#slime-object","text":"Quote Next, with the slime's object. Similarly, this will be mostly just defining stuff. Lionmeow It's a bit better than the slime definition, it's just defining stuff.","title":"Slime Object"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_object/#code-example","text":"GameObject slimeObject = PrefabUtils . CopyPrefab ( SRSingleton < GameContext >. Instance . LookupDirector . GetPrefab ( Identifiable . Id . PINK_SLIME )); slimeObject . name = \"slimeSlime\" ; slimeObject . GetComponent < PlayWithToys >(). slimeDefinition = slimeDefinition ; slimeObject . GetComponent < SlimeAppearanceApplicator >(). SlimeDefinition = slimeDefinition ; slimeObject . GetComponent < SlimeEat >(). slimeDefinition = slimeDefinition ; slimeObject . GetComponent < Identifiable >(). id = Id . SLIME_SLIME ; UnityEngine . Object . Destroy ( slimeObject . GetComponent < PinkSlimeFoodTypeTracker >()); Quote The first line is just copying the pink slime's gameobject, similar to what we did with the slime definition. We now name the object. The naming convention is 'slime' followed by the name of the slime. So if the slime was a digital slime than it would be named slimeDigital. We then just make sure the slime definition of a few components are set to the right one, PlayWithToys, SlimeAppearanceApplicator, SlimeEat. We set its identifiable.id, and finally, we remove the PinkSlimeFoodTypeTracker from it because if we didn't then that'd track progress towards that one pink slime achievement.** Lionmeow As promised, it is not as long the slime definition, is that not great?","title":"Code example"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_object/#first-line","text":"GameObject slimeObject = PrefabUtils.CopyPrefab(SRSingleton<GameContext>.Instance.LookupDirector.GetPrefab(Identifiable.Id.PINK_SLIME)); Copying the GameObject of a normal pink slime.","title":"First Line"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_object/#second-line","text":"slimeObject.name = \"slimeSlime\"; Setting the name.","title":"Second Line"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_object/#third-fifth-line","text":"slimeObject.GetComponent<PlayWithToys>().slimeDefinition = slimeDefinition; We are getting the Component of type PlayWithToy, getting it's slimeDefinition and setting our definition there. The same for the fourth and fifth lines (only that we get other components).","title":"Third-Fifth Line"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_object/#sixth-line","text":"slimeObject.GetComponent<Identifiable>().id = Id.SLIME_SLIME; Setting the id of the slime object to our custom id (it need to be your id).","title":"Sixth Line"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_object/#seventh-line","text":"UnityEngine.Object.Destroy(slimeObject.GetComponent<PinkSlimeFoodTypeTracker>()); Destroying the PinkSlimeFoodTypeTracker Component of our slime object because if we didn't then that'd track progress towards that one pink slime achievement (we don't want it)","title":"Seventh Line"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_object/#conclusion","text":"This is the most short code snippet, the next will talk about the slime appearance , wich is much larger. Time to read the last section on how to create your slime! You can find the final code in the tutorial's section Creating a constructor function","title":"Conclusion"},{"location":"Slime_Rancher/SRML/CustomSlime/custom_slimes_object/#return-to-the-main-place","text":"","title":"Return to the main place"},{"location":"Slime_Rancher/SRML/CustomSlime/final_steps/","text":"Final steps Well, after all our hard work, we are coming to the end. Congratulations! There are some smaller extra steps to do and you will be able to test your slime! Creating a constructor function All that work for only one slime, but imagine if you were doing this for 4 slimes? You can't repeat and repeat the same code over the time, so it's time to use a function! I already told you a bit how I do it, so we only have to make a function from this mess: using System ; using System.Collections.Generic ; using System.Linq ; using System.Text ; using System.Threading.Tasks ; using SRML.Utils ; using UnityEngine ; namespace Custom_Creator { class Custom_Creator { public static ( SlimeDefinition , GameObject ) CreateSlime ( Identifiable . Id SlimeId , String SlimeName ) { SlimeDefinition pinkSlimeDefinition = SRSingleton < GameContext >. Instance . SlimeDefinitions . GetSlimeByIdentifiableId ( Identifiable . Id . PINK_SLIME ); SlimeDefinition slimeDefinition = ( SlimeDefinition ) PrefabUtils . DeepCopyObject ( pinkSlimeDefinition ); slimeDefinition . AppearancesDefault = new SlimeAppearance [ 1 ]; slimeDefinition . Diet . Produces = new Identifiable . Id [ 1 ] { Identifiable . Id . GOLD_PLORT }; slimeDefinition . Diet . MajorFoodGroups = new SlimeEat . FoodGroup [ 1 ] { SlimeEat . FoodGroup . VEGGIES }; slimeDefinition . Diet . AdditionalFoods = new Identifiable . Id [ 0 ]; slimeDefinition . Diet . Favorites = new Identifiable . Id [ 1 ] { Identifiable . Id . CARROT_VEGGIE }; slimeDefinition . Diet . EatMap ?. Clear (); slimeDefinition . CanLargofy = false ; slimeDefinition . FavoriteToys = new Identifiable . Id [ 0 ]; slimeDefinition . Name = SlimeName ; slimeDefinition . IdentifiableId = SlimeId ; GameObject slimeObject = PrefabUtils . CopyPrefab ( SRSingleton < GameContext >. Instance . LookupDirector . GetPrefab ( Identifiable . Id . PINK_SLIME )); slimeObject . name = \"slimeSlime\" ; slimeObject . GetComponent < PlayWithToys >(). slimeDefinition = slimeDefinition ; slimeObject . GetComponent < SlimeAppearanceApplicator >(). SlimeDefinition = slimeDefinition ; slimeObject . GetComponent < SlimeEat >(). slimeDefinition = slimeDefinition ; slimeObject . GetComponent < Identifiable >(). id = SlimeId ; UnityEngine . Object . Destroy ( slimeObject . GetComponent < PinkSlimeFoodTypeTracker >()); SlimeAppearance slimeAppearance = ( SlimeAppearance ) PrefabUtils . DeepCopyObject ( pinkSlimeDefinition . AppearancesDefault [ 0 ]); slimeDefinition . AppearancesDefault [ 0 ] = slimeAppearance ; SlimeAppearanceStructure [] structures = slimeAppearance . Structures ; foreach ( SlimeAppearanceStructure slimeAppearanceStructure in structures ) { Material [] defaultMaterials = slimeAppearanceStructure . DefaultMaterials ; if ( defaultMaterials != null && defaultMaterials . Length != 0 ) { Material material = UnityEngine . Object . Instantiate ( SRSingleton < GameContext >. Instance . SlimeDefinitions . GetSlimeByIdentifiableId ( Identifiable . Id . PINK_SLIME ). AppearancesDefault [ 0 ]. Structures [ 0 ]. DefaultMaterials [ 0 ]); material . SetColor ( \"_TopColor\" , new Color32 ( 190 , 28 , 255 , 255 )); material . SetColor ( \"_MiddleColor\" , new Color32 ( 159 , 28 , 255 , 255 )); material . SetColor ( \"_BottomColor\" , new Color32 ( 120 , 28 , 255 , 255 )); material . SetColor ( \"_SpecColor\" , new Color32 ( 205 , 28 , 255 , 255 )); material . SetFloat ( \"_Shininess\" , 1f ); material . SetFloat ( \"_Gloss\" , 1f ); slimeAppearanceStructure . DefaultMaterials [ 0 ] = material ; } } SlimeExpressionFace [] expressionFaces = slimeAppearance . Face . ExpressionFaces ; for ( int k = 0 ; k < expressionFaces . Length ; k ++) { SlimeExpressionFace slimeExpressionFace = expressionFaces [ k ]; if (( bool ) slimeExpressionFace . Mouth ) { slimeExpressionFace . Mouth . SetColor ( \"_MouthBot\" , new Color32 ( 205 , 190 , 255 , 255 )); slimeExpressionFace . Mouth . SetColor ( \"_MouthMid\" , new Color32 ( 182 , 170 , 226 , 255 )); slimeExpressionFace . Mouth . SetColor ( \"_MouthTop\" , new Color32 ( 182 , 170 , 205 , 255 )); } if (( bool ) slimeExpressionFace . Eyes ) { slimeExpressionFace . Eyes . SetColor ( \"_EyeRed\" , new Color32 ( 205 , 190 , 255 , 255 )); slimeExpressionFace . Eyes . SetColor ( \"_EyeGreen\" , new Color32 ( 182 , 170 , 226 , 255 )); slimeExpressionFace . Eyes . SetColor ( \"_EyeBlue\" , new Color32 ( 182 , 170 , 205 , 255 )); } } slimeAppearance . Face . OnEnable (); slimeAppearance . ColorPalette = new SlimeAppearance . Palette { Top = new Color32 ( 159 , 28 , 255 , 255 ), Middle = new Color32 ( 120 , 28 , 255 , 255 ), Bottom = new Color32 ( 190 , 28 , 255 , 255 ) }; slimeObject . GetComponent < SlimeAppearanceApplicator >(). Appearance = slimeAppearance ; return ( slimeDefinition , slimeObject ); } } } Register the slime Now we are able to create our own slimes, but they don't exist in the game. This is because we don't registered them. Promise, this will not take too long, add this in your main Load or PostLoad function: ( SlimeDefinition , GameObject ) SlimeTuple = Custom_Creator . CreateSlime ( ModdedIds . Ids . SLIME_SLIME , \"Slime Slime\" ); //Insert your own Id in the first argumeter //Getting the SlimeDefinition and GameObject separated SlimeDefinition Slime_Slime_Definition = SlimeTuple . Item1 ; GameObject Slime_Slime_Object = SlimeTuple . Item2 ; //And well, registering it! LookupRegistry . RegisterIdentifiablePrefab ( Slime_Slime_Object ); SlimeRegistry . RegisterSlimeDefinition ( Slime_Slime_Definition ); Conclusion This is a really long tutorial, one of the longest. Now have fun by testing your slime! To spawn it, you use the command bar (crtl + tab). The next tutorial will talking about creating custom food. Time to celebrate! Return to the main place","title":"Final steps"},{"location":"Slime_Rancher/SRML/CustomSlime/final_steps/#final-steps","text":"Well, after all our hard work, we are coming to the end. Congratulations! There are some smaller extra steps to do and you will be able to test your slime!","title":"Final steps"},{"location":"Slime_Rancher/SRML/CustomSlime/final_steps/#creating-a-constructor-function","text":"All that work for only one slime, but imagine if you were doing this for 4 slimes? You can't repeat and repeat the same code over the time, so it's time to use a function! I already told you a bit how I do it, so we only have to make a function from this mess: using System ; using System.Collections.Generic ; using System.Linq ; using System.Text ; using System.Threading.Tasks ; using SRML.Utils ; using UnityEngine ; namespace Custom_Creator { class Custom_Creator { public static ( SlimeDefinition , GameObject ) CreateSlime ( Identifiable . Id SlimeId , String SlimeName ) { SlimeDefinition pinkSlimeDefinition = SRSingleton < GameContext >. Instance . SlimeDefinitions . GetSlimeByIdentifiableId ( Identifiable . Id . PINK_SLIME ); SlimeDefinition slimeDefinition = ( SlimeDefinition ) PrefabUtils . DeepCopyObject ( pinkSlimeDefinition ); slimeDefinition . AppearancesDefault = new SlimeAppearance [ 1 ]; slimeDefinition . Diet . Produces = new Identifiable . Id [ 1 ] { Identifiable . Id . GOLD_PLORT }; slimeDefinition . Diet . MajorFoodGroups = new SlimeEat . FoodGroup [ 1 ] { SlimeEat . FoodGroup . VEGGIES }; slimeDefinition . Diet . AdditionalFoods = new Identifiable . Id [ 0 ]; slimeDefinition . Diet . Favorites = new Identifiable . Id [ 1 ] { Identifiable . Id . CARROT_VEGGIE }; slimeDefinition . Diet . EatMap ?. Clear (); slimeDefinition . CanLargofy = false ; slimeDefinition . FavoriteToys = new Identifiable . Id [ 0 ]; slimeDefinition . Name = SlimeName ; slimeDefinition . IdentifiableId = SlimeId ; GameObject slimeObject = PrefabUtils . CopyPrefab ( SRSingleton < GameContext >. Instance . LookupDirector . GetPrefab ( Identifiable . Id . PINK_SLIME )); slimeObject . name = \"slimeSlime\" ; slimeObject . GetComponent < PlayWithToys >(). slimeDefinition = slimeDefinition ; slimeObject . GetComponent < SlimeAppearanceApplicator >(). SlimeDefinition = slimeDefinition ; slimeObject . GetComponent < SlimeEat >(). slimeDefinition = slimeDefinition ; slimeObject . GetComponent < Identifiable >(). id = SlimeId ; UnityEngine . Object . Destroy ( slimeObject . GetComponent < PinkSlimeFoodTypeTracker >()); SlimeAppearance slimeAppearance = ( SlimeAppearance ) PrefabUtils . DeepCopyObject ( pinkSlimeDefinition . AppearancesDefault [ 0 ]); slimeDefinition . AppearancesDefault [ 0 ] = slimeAppearance ; SlimeAppearanceStructure [] structures = slimeAppearance . Structures ; foreach ( SlimeAppearanceStructure slimeAppearanceStructure in structures ) { Material [] defaultMaterials = slimeAppearanceStructure . DefaultMaterials ; if ( defaultMaterials != null && defaultMaterials . Length != 0 ) { Material material = UnityEngine . Object . Instantiate ( SRSingleton < GameContext >. Instance . SlimeDefinitions . GetSlimeByIdentifiableId ( Identifiable . Id . PINK_SLIME ). AppearancesDefault [ 0 ]. Structures [ 0 ]. DefaultMaterials [ 0 ]); material . SetColor ( \"_TopColor\" , new Color32 ( 190 , 28 , 255 , 255 )); material . SetColor ( \"_MiddleColor\" , new Color32 ( 159 , 28 , 255 , 255 )); material . SetColor ( \"_BottomColor\" , new Color32 ( 120 , 28 , 255 , 255 )); material . SetColor ( \"_SpecColor\" , new Color32 ( 205 , 28 , 255 , 255 )); material . SetFloat ( \"_Shininess\" , 1f ); material . SetFloat ( \"_Gloss\" , 1f ); slimeAppearanceStructure . DefaultMaterials [ 0 ] = material ; } } SlimeExpressionFace [] expressionFaces = slimeAppearance . Face . ExpressionFaces ; for ( int k = 0 ; k < expressionFaces . Length ; k ++) { SlimeExpressionFace slimeExpressionFace = expressionFaces [ k ]; if (( bool ) slimeExpressionFace . Mouth ) { slimeExpressionFace . Mouth . SetColor ( \"_MouthBot\" , new Color32 ( 205 , 190 , 255 , 255 )); slimeExpressionFace . Mouth . SetColor ( \"_MouthMid\" , new Color32 ( 182 , 170 , 226 , 255 )); slimeExpressionFace . Mouth . SetColor ( \"_MouthTop\" , new Color32 ( 182 , 170 , 205 , 255 )); } if (( bool ) slimeExpressionFace . Eyes ) { slimeExpressionFace . Eyes . SetColor ( \"_EyeRed\" , new Color32 ( 205 , 190 , 255 , 255 )); slimeExpressionFace . Eyes . SetColor ( \"_EyeGreen\" , new Color32 ( 182 , 170 , 226 , 255 )); slimeExpressionFace . Eyes . SetColor ( \"_EyeBlue\" , new Color32 ( 182 , 170 , 205 , 255 )); } } slimeAppearance . Face . OnEnable (); slimeAppearance . ColorPalette = new SlimeAppearance . Palette { Top = new Color32 ( 159 , 28 , 255 , 255 ), Middle = new Color32 ( 120 , 28 , 255 , 255 ), Bottom = new Color32 ( 190 , 28 , 255 , 255 ) }; slimeObject . GetComponent < SlimeAppearanceApplicator >(). Appearance = slimeAppearance ; return ( slimeDefinition , slimeObject ); } } }","title":"Creating a constructor function"},{"location":"Slime_Rancher/SRML/CustomSlime/final_steps/#register-the-slime","text":"Now we are able to create our own slimes, but they don't exist in the game. This is because we don't registered them. Promise, this will not take too long, add this in your main Load or PostLoad function: ( SlimeDefinition , GameObject ) SlimeTuple = Custom_Creator . CreateSlime ( ModdedIds . Ids . SLIME_SLIME , \"Slime Slime\" ); //Insert your own Id in the first argumeter //Getting the SlimeDefinition and GameObject separated SlimeDefinition Slime_Slime_Definition = SlimeTuple . Item1 ; GameObject Slime_Slime_Object = SlimeTuple . Item2 ; //And well, registering it! LookupRegistry . RegisterIdentifiablePrefab ( Slime_Slime_Object ); SlimeRegistry . RegisterSlimeDefinition ( Slime_Slime_Definition );","title":"Register the slime"},{"location":"Slime_Rancher/SRML/CustomSlime/final_steps/#conclusion","text":"This is a really long tutorial, one of the longest. Now have fun by testing your slime! To spawn it, you use the command bar (crtl + tab). The next tutorial will talking about creating custom food. Time to celebrate!","title":"Conclusion"},{"location":"Slime_Rancher/SRML/CustomSlime/final_steps/#return-to-the-main-place","text":"","title":"Return to the main place"},{"location":"Slime_Rancher/SRML/CustomSlime/getting_started/","text":"Getting started Quote Making a slime is split into three parts. making the slime's object, making the slime's definition, and making the slime's appearance. This will all be in load or postload. I usually do it in load. Warning Here's an important warning: if you don't wanna break your save, make sure, if you're removing a custom identifiable.id that's linked to an object, that you delete all instances of that object in your save. Quote Lionmeow Basic Requirements You will need be able to create custom Enums (click here to see the tutorial if you missed it) Planning What we are going to do is to creating our own slime. It long, and seems like a bunch of no sense, but you will see that we are only defining stuff, nothing more Theory In a nutshell, a slime's code is divided into 3 sections: The slime's definition (The informations of the slime) The slime's object (The \"main body\" of the slime) The slime's appearance (The aspect of the slime) Each one of the sections has a role and combined they create a slime Locating This will be a \"huge\" code, you should create another, custom, class for this. What I did was to create a class called Custom_Creator with a function called CreateSlime(Identifiable.Id SlimeId, String SlimeName) (it returns a (SlimeDefinition, GameObject) tuple) Required Namespaces You will need require the UnityEngine and SRML.Utils namespaces, this can be done writing: using SRML.Utils ; using UnityEngine ; Continue Now, because this may be really long to put it only in one page, you have 4 pages wich, 3 cover the 3 sections and 1 just explain additional stuff: Slime's Definition Slime's Object Slime's Appearance The final steps","title":"Getting started"},{"location":"Slime_Rancher/SRML/CustomSlime/getting_started/#getting-started","text":"Quote Making a slime is split into three parts. making the slime's object, making the slime's definition, and making the slime's appearance. This will all be in load or postload. I usually do it in load. Warning Here's an important warning: if you don't wanna break your save, make sure, if you're removing a custom identifiable.id that's linked to an object, that you delete all instances of that object in your save. Quote Lionmeow","title":"Getting started"},{"location":"Slime_Rancher/SRML/CustomSlime/getting_started/#basic-requirements","text":"You will need be able to create custom Enums (click here to see the tutorial if you missed it)","title":"Basic Requirements"},{"location":"Slime_Rancher/SRML/CustomSlime/getting_started/#planning","text":"What we are going to do is to creating our own slime. It long, and seems like a bunch of no sense, but you will see that we are only defining stuff, nothing more","title":"Planning"},{"location":"Slime_Rancher/SRML/CustomSlime/getting_started/#theory","text":"In a nutshell, a slime's code is divided into 3 sections: The slime's definition (The informations of the slime) The slime's object (The \"main body\" of the slime) The slime's appearance (The aspect of the slime) Each one of the sections has a role and combined they create a slime","title":"Theory"},{"location":"Slime_Rancher/SRML/CustomSlime/getting_started/#locating","text":"This will be a \"huge\" code, you should create another, custom, class for this. What I did was to create a class called Custom_Creator with a function called CreateSlime(Identifiable.Id SlimeId, String SlimeName) (it returns a (SlimeDefinition, GameObject) tuple)","title":"Locating"},{"location":"Slime_Rancher/SRML/CustomSlime/getting_started/#required-namespaces","text":"You will need require the UnityEngine and SRML.Utils namespaces, this can be done writing: using SRML.Utils ; using UnityEngine ;","title":"Required Namespaces"},{"location":"Slime_Rancher/SRML/CustomSlime/getting_started/#continue","text":"Now, because this may be really long to put it only in one page, you have 4 pages wich, 3 cover the 3 sections and 1 just explain additional stuff: Slime's Definition Slime's Object Slime's Appearance The final steps","title":"Continue"}]}